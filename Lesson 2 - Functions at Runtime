â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘   Object-Oriented JavaScript  â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  2. Functions at Runtime
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  2.1. Introduction
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  2.2. First-Class Functions
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  En JavaScript, las funciones son First-Class Functions. Esto quiere decir que existen ciertos
  privilegios que no todos los lenguajes tienen. El mismo soporte para distintas estructuras de
  datos: numbers, strings, objects, arrays, etc.

  Pensemos en un string:
  - Puede ser alojado en una variable
  - Puede ser retornado de una funciÃ³n
  - Puede ser pasado como argumento en una funciÃ³n

  Esto quiere decir, que en JavaScript las funciones de primera clase tienen los mismos privilegios
  que otras estructuras de datos.

  FunciÃ³n anÃ³nima guardada en una constante
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const myFunction = function(n1, n2){
      return n1 * n2;
  };

  myFunction(2, 4);

  FunciÃ³n nombrada guardada en una constante
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const myFunction = function Suma(n1, n2){
      return n1 * n2;
  };

  myFunction(2, 4);

  FunciÃ³n sÃ³lo declarada
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function average(n1, n2, n3){
      return (n1 + n2 + n3) / 3;
  }

  average.length
  //3

  average.name
  //average

  Como las funciones son objetos tambiÃ©n podemos acceder a sus propiedades

  Functions Can Return Functions
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Recordar que una funciÃ³n debe siempre retornar un valor. 
  - De manera explÃ­cita, con return statement (e.g., returning a string, boolean, array, etc.)
  - De manera implÃ­cita, con return indefinido (e.g., a function that simply logs something to the console), 
  Una funciÃ³n debe siempre retornar un solo valor.

  Como las funciones de primera clase pueden tratarse como cualquier otro valor, ahora
  sabemos que podemos retornar una funciÃ³n desde otra funciÃ³n.
  Una funciÃ³n que retorna otra funciÃ³n es conocida como high-order functions.

  function alertThenReturn() {
    alert('Message 1!');

    return function () {
      alert('Message 2!');
    };
  }
  console.log(alertThenReturn());
  // Solo veremos Message 1!

  Para ver el return de la segunda funciÃ³n deberÃ­amos estorearlo en una variable:
  const innerFunction = alertThenReturn();
  Con esto, lo que estamos haciendo, es alojar el resultado de esa funciÃ³n en una variable.
  Entonces llamando a esa variable podemos acceder a ella.
  innerFunction();
  // alerts 'Message 2!'

  De todas formas no es necesario alojar la funciÃ³n en una variable para acceder al segundo 
  alert. Podemos acceder a ambos resultados esperados, utilizando doble parÃ©ntesis.
  console.log(alertThenReturn()());

  Summary
  â•â•â•â•â•â•â•
  In the JavaScript language, functions are first-class functions. This means that we can do 
  with functions just about everything that we can do with other elements in JavaScript, such 
  as strings, arrays, or numbers. JavaScript functions can:
  - Be stored in variables
  - Be returned from a function.
  - Be passed as arguments into another function.

  We ve seen quite a few examples of the first two in the list, but what about passing a function 
  as an argument into another function? Since this is such an important and common pattern in 
  JavaScript, we ll take a deep dive in the next section!

  Further Research
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - First-class function on Wikipedia: https://en.wikipedia.org/wiki/First-class_function

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  2.3. Callback Functions
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Recall that JavaScript functions are first-class functions. We can do with functions just about 
  everything we can do with other values -- including passing them into other functions! 
  A function that takes other functions as arguments (and/or returns a function, as we learned 
  in the previous section) is known as a higher-order function. A function that is passed as an 
  argument into another function is called a callback function.

  We will be focusing on callbacks in this section. Callback functions are great because they can
  delegate calling functions to other functions. They allow you to build your applications with
  composition, leading to cleaner and more efficient code.

  function highOrder(callback){
  }

  function highOrder(){
      return callback(){
      }
  }

  function callAndAdd(n, callbackFunction){
      return n + callbackFunction();
  }

  function returnsThree(){
      return 3;
  }

  callAndAdd(2, returnsThree);
  // 5
  // 2 + 3

  Array Methods
  â•â•â•â•â•â•â•â•â•â•â•â•â•
  Las funciones son pasadas en un array method y llamada por cada elemento dentro del array (el
  array donde el mÃ©todo fue invocado).

  - forEach()
  - map()
  - filter()

  forEach()
  â•â•â•â•â•â•â•â•â•
  Toma una funciÃ³n callback e invoca esa funciÃ³n para cada elemento en el array.
  En otras palabras, permite iterar a travÃ©s del array, similar usando un for loop.

  array.forEach(function callback(currentValue, index, array) {
      // function code here
  });

  La funciÃ³n coallback recibe los argumentos: el array actual, su index y el array completo.
  Digamos que tenemos una funciÃ³n simple, logIfOdd(), que toma un nÃºmero simple y muestra en 
  consola si es impar.

  function logIfOdd(n) {
    if (n % 2 !== 0) {
      console.log(n);
    }
  }

  logIfOdd(2);
  // (nothing is logged)

  logIfOdd(3);
  // 3

  Ahora quÃ© pasa si queremos chequear todo un array? Podmeos hacerlo a travÃ©s del forEach y 
  pasar la funciÃ³n logIfOdd como callback.

  [1, 5, 2, 4, 6, 3].forEach(function logIfOdd(n) {
    if (n % 2 !== 0) {
      console.log(n);
    }
  });

  // 1
  // 5
  // 3

  map()
  â•â•â•â•â•
  Es similar al forEach. Se invoca una funciÃ³n callback por cada elemento en el array.
  Sin embargo, map() retorna un nuevo array basado en lo retornado de la funciÃ³n.

  const names = ['David', 'Richard', 'Veronika'];

  const nameLengths = names.map(function(name) {
    return name.length;
  });

  Recordar: forEach() no retorna nada, mientras map() retorna un nuevo array con los valores
  que son retornados desde la funciÃ³n.

  Ejercicio
  â•â•â•â•â•â•â•â•â•
  /* Using map()
  *
  * Using the musicData array and map():
  *   - Return a string for each item in the array in the following format:
  *     <album-name> by <artist> sold <sales> copies
  *   - Store the returned data in a new albumSalesStrings variable
  *
  * Note:
  *   - Do not delete the musicData variable
  *   - Do not alter any of the musicData content
  *   - Do not format the sales number leave it as a long string of digits
  */

  const musicData = [
      { artist: 'Adele', name: '25', sales: 1731000 },
      { artist: 'Drake', name: 'Views', sales: 1608000 },
      { artist: 'Beyonce', name: 'Lemonade', sales: 1554000 },
      { artist: 'Chris Stapleton', name: 'Traveller', sales: 1085000 },
      { artist: 'Pentatonix', name: 'A Pentatonix Christmas', sales: 904000 },
      { artist: 'Original Broadway Cast Recording', 
        name: 'Hamilton: An American Musical', sales: 820000 },
      { artist: 'Twenty One Pilots', name: 'Blurryface', sales: 738000 },
      { artist: 'Prince', name: 'The Very Best of Prince', sales: 668000 },
      { artist: 'Rihanna', name: 'Anti', sales: 603000 },
      { artist: 'Justin Bieber', name: 'Purpose', sales: 554000 }
  ];

  const albumSalesStrings = musicData.map(album =>{
      return album.name + ' by ' + album.artist + ' sold ' + album.sales + ' copies'
  })

  console.log(albumSalesStrings);

  filter()
  â•â•â•â•â•â•â•â•
  Es similar a map
  - Se llama en un array
  - Toma una funciÃ³n como argumento
  - Retorna un nuevo array

  La diferencia es que la funciÃ³n pasada es usada como test, y sÃ³lo los items del array
  que pasan el test son incluidos en un nuevo array.

  const names = ['David', 'Richard', 'Veronika'];

  const shortNames = names.filter(function(name) {
    return name.length < 6;
  });

  De nuevo, la funciÃ³n que es pasada a filter se llama para cada item del array.
  El primer elemento, 'David', es alojado en la variable name, se performa el test.
  Si es igual o mayor a 6 es salteado y no incluido en el array. Pero si es menor,
  es incluido en el nuevo array. 

  Recordar: filter() retorna un nuevo array, no modifica el anterior.

  Ejercicio
  â•â•â•â•â•â•â•â•â•
  /* Using filter()
  * 
  * Using the musicData array and filter():
  *   - Return only album objects where the album s name is
  *     10 characters long, 25 characters long, or anywhere in between
  *   - Store the returned data in a new `results` variable
  *
  * Note:
  *   - Do not delete the musicData variable
  *   - Do not alter any of the musicData content
  */

  const musicData = [
      { artist: 'Adele', name: '25', sales: 1731000 },
      { artist: 'Drake', name: 'Views', sales: 1608000 },
      { artist: 'Beyonce', name: 'Lemonade', sales: 1554000 },
      { artist: 'Chris Stapleton', name: 'Traveller', sales: 1085000 },
      { artist: 'Pentatonix', name: 'A Pentatonix Christmas', sales: 904000 },
      { artist: 'Original Broadway Cast Recording', 
        name: 'Hamilton: An American Musical', sales: 820000 },
      { artist: 'Twenty One Pilots', name: 'Blurryface', sales: 738000 },
      { artist: 'Prince', name: 'The Very Best of Prince', sales: 668000 },
      { artist: 'Rihanna', name: 'Anti', sales: 603000 },
      { artist: 'Justin Bieber', name: 'Purpose', sales: 554000 }
  ];

  const results = musicData.filter(album =>{
      if(album.name.length >= 10 && album.name.length <= 25){
          return album;
      }
  })

  console.log(results);

  Summary
  â•â•â•â•â•â•â•
  Funciones en JS pueden tomar una variedad de diferentes argumentos: strings, nÃºmeros,
  arrays, objetos. Como las funciones son funciones de primera clase, tambiÃ©n pueden ser
  pasadas como argumentos a una funciÃ³n dada.
  Las funciones que toman otras funciones como argumentos son llamadas funciones de alto orden.
  Funciones que son pasadas como argumentos a otras funciones son llamadas funciones callback.

  Las callbacks te permiten pasar funciones sin necesidad de nombrarlas (funciones anÃ³nimas), lo
  que lleva a tener menos funciones flotando por ahÃ­. Esto tambiÃ©n permite delegar funciones a otras
  funciones. 

  Los mÃ©todos de array como, forEach(), map() y filter() aprovechan los callbacks para ejecutar
  otras funciones sobre los elementos del array. Hay otros mÃ©todos array como: 
  - Create: let fruits = ['Apple', 'Banana']
  - Access: 
    - let last = fruits[fruits.length - 1]
    - let first = fruits[0]
    - let first = fruits.0
    - let fruit = fruits['Apple']
    - Object.keys
    - Object.values
    - indexOf
  - length
  - push
  - pop
  - shift
  - unshift
  - splice
  - slice
  - join
  - find
  - findIndex
  - flat
  - includes
  - reverse
  - sort
  - some
  - every
  - toString
  - Otros

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  2.4. Scope
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Block Scope vs. Function Scope
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Esto diferencia hasta donde puede ser vista una variable en el cÃ³digo.
  Los cientÃ­ficos de datos llaman a esto lexical scope.

  TambiÃ©n existe otro tipo de scope llamado runtime scope. Cuando una funciÃ³n es ejecutada,
  se crea un nuevo runtime scope. Este scope representa el contexto de una funciÃ³n, o mÃ¡s
  especÃ­ficamente, un set de variables disponibles que dispone la funciÃ³n para utilizar.

  Las funciones tienen acceso a:
  - A los argumentos pasados a la funciÃ³n, sean nÃºmeros, strings u otras funciones.
  - A todas las variables declaradas dentro de la funciÃ³n.
  - A las mismas variables que la funciÃ³n padre use:
    - sus variables locales
    - sus argumentos
    - las variables dentro del scope de la funciÃ³n padre de esa funciÃ³n padre.
  - A las funciones globales.

  Scope
  â•â•â•â•â•
  El runtime scope de una funciÃ³n describe las variables disponibles para el uso dentro 
  de una funciÃ³n dada. El cÃ³digo dentro de la funciÃ³n tiene acceso a:
  - Los argumentos de la funciÃ³n
  - Las variables locales declaradas dentro de esa funciÃ³n
  - Las variables dentro del scope de la funciÃ³n padre
  - Las variables globales

  const a = 'a'

  function parent(){
    const b = 'b';

    function child(){
      const c = 'c';
    }
  }

  La funciÃ³n anidada child() tiene acceso a las variables a, b y c. Esto quiere decir que todas
  estÃ¡n dentro del scope de la funciÃ³n.

  const myName = 'Andrea';

  function introduceMySelf(){
    const you = 'student';

    function introduce() {
      return `Hello ${you}, I am ${myName}`;
    }
    return introduce();
  }

  console.log(introduceMySelf());

  Ejercicio
  â•â•â•â•â•â•â•â•â•
  const num1 = 5;

  function functionOne() {
    const num2 = 10;
    function functionTwo(num3) {
      const num4 = 35;
      return num1 + num2 + num3 + num4;
    }
    return functionTwo(0);
  }

  Which variables does functionTwo() have access to? Select all that apply: num1, num2, num3 y num4

  JavaScript is Function-Scoped
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Function-Scoping
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Tradicionalmente, las variables son definidas en el scope de una funciÃ³n, en vez de el scope de un
  bloque. Como al entrar a una funciÃ³n cambiarÃ¡ el scope, todas las variables definidas dentro de la 
  funciÃ³n no estarÃ¡n disponibles por fuera de ella. Por otro lado, si hay variables deifinidas dentro
  de un bloque, por ej. un if statement, esas variables estarÃ¡n disponibles fuera de ese bloque.

  Ejemplo:
  var globalNumber = 5;

  function globalIncrementer() {
    const localNumber = 10;

    globalNumber += 1;
    return globalNumber;
  }

  Block-Scoping
  â•â•â•â•â•â•â•â•â•â•â•â•â•
  ES6 permite scope adicional con las variables con let y const.
  Estas variables son utilizadas para declarar variables block-scope y reemplazar var.
  Para saber mÃ¡s:
  - let: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let
  - const: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const

  Curso: https://www.udacity.com/course/es6-javascript-improved--ud356

  Scope Chain
  â•â•â•â•â•â•â•â•â•â•â•
  Cuando sea que el cÃ³digo atente a acceder a variables durante una llamada a una funciÃ³n, el
  interpreter de JS siemmpre comenzarÃ¡ por mirar las propias variables locales. Si no encuentra
  ninguna la bÃºsqueda continuarÃ¡ en lo que se llama una scope chain.

  function one() {
    two();
    function two() {
      three();
      function three() {
        // function three s code here
      }
    }
  }
  one();

  El scope chain en este caso podemos verlo moverse hacia afuera desde el nivel mÃ¡s anidado.
  three(), two(), one() y window y de esta manera three() puede acceder a todas las variables,
  no sÃ³lo dentro de one() y two(), sino cualquier funciÃ³n global definida fuera de one().

    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    â•‘ Child               â•‘  
    â•‘ â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•— â•‘
    â•‘ â•‘ Parent          â•‘ â•‘
    â•‘ â•‘ â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•— â•‘ â•‘
    â•‘ â•‘ â•‘ Global      â•‘ â•‘ â•‘
    â•‘ â•‘ â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â• â•‘ â•‘
    â•‘ â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• â•‘
    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• 

  JS engine begings to look for the variable
                      â†“
  Is the variable defined in the child function? â†’ Value is retrieved
                      â†“
  Is the variable defined in the parent function? â†’ Value is retrieved
                      â†“
  Is the variable defined in the global environment? â†’ Value is retrieved
                      â†“
                  Undefined

  ğŸ’¡ The Global (window) Object ğŸ’¡
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Recordar que apps JS corren dentro de un ambiente host, por ej. un browser, el host provee un window object,
  tambiÃ©n conocido como objeto global. Cualquier variable global declarada es accedida como propiedad de este
  objeto, que representa el nivel mÃ¡s externo de la scope chain.

  Variable Shadowing
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  QuÃ© pasa cuando creamos una varibale con el mismo nombre que otra variable en algÃºn lugar de la scope chain?
  JS no tirarÃ¡ un error o prevendrÃ¡ que crees otra variable extra. De hecho, la variable con scope local sÃ³lo
  temporalmente ensombrecerÃ¡ a la variable externa. Esto es llamado variable shadowing.

  const symbol = 'Â¥';
  function displayPrice(price) {
    const symbol = '$';
    console.log(symbol + price);
  }
  displayPrice('80');
  // '$80'

  Entonces, si hay superposiciones de nombres en diferentes contextos, se resolverÃ¡ moviendo la scope chain
  de adentro hacia afuera. De este modo, todas las variables locales con el mismo nombre que las externas 
  tomarÃ¡n precedencia por sobre aquellas que estÃ©n en un scope mÃ¡s abierto.

  Ejercicio
  â•â•â•â•â•â•â•â•â•
  What will the console display when myFunction() is called?

  let n = 2;

  function myFunction() {
    let n = 8;
    console.log(n);
  }

  myFunction();
  // 8

  Ejercicio
  â•â•â•â•â•â•â•â•â•
  When the following code runs, what is the output of the first, second, and third logs to 
  the console (respectively)?

  let n = 8;

  function functionOne() {
    let n = 9;

    function functionTwo() {
      let n = 10;
      console.log(n);  // First log
    }

    functionTwo();

    console.log(n);  // Second log
  }

  functionOne();

  console.log(n);  // Third log

  // 10, 9, 8

  Summary
  â•â•â•â•â•â•â•
  Cuando una funciÃ³n es ejecutrada crea su propio scope. El scope de una funciÃ³n es un set de 
  variables disponibles para su uso dentro de esa funciÃ³n. El scope de una funciÃ³n incluye:
  1. Los argumentos de la funciÃ³n
  2. Variables locales declaradas dentro de la funciÃ³n
  3. Variables dentro de la funciÃ³n padre
  4. Variables globales

  La variables en JS tambiÃ©n son function-scoped. Esto quiere decir que las variables declaradas
  dentro de una funciÃ³n no estÃ¡n disponibles fuera de esa funciÃ³n, aunque variables definidas dentro
  de bloques, por ejemplo dentro de un if, sÃ­ estÃ¡n disponibles fuera de ese bloque.

  Cuando se trata de acceder a variables, el motor JS atravesarÃ¡ la scope chain, primero mirando el
  nivel mÃ¡s interno, por ejemplo las variables declaradas localmente dentro de una funciÃ³n, luego 
  scopes mÃ¡s externos y llegando al global scope si fuera necesario.

  Further Research
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - Intro to JavaScript (Lesson 5): https://www.udacity.com/course/intro-to-javascript--ud803
  - Douglas Crockfords discussion of block-scoped variables in The Better Parts: https://www.youtube.com/watch?v=Ji6NHEnNHcA&t=26m9s
  - Block Scoping Rules on MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block#Description
  - Functions and Function Scope on MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  2.5. Closures
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Functions Retain Their Scope
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Entonces, cuando un identificador (una variable) es utilizada, el motor de JS comenzarÃ¡ a chequear
  en busca del valor para ese identificador dentro del scope chain. Puede que ese identificador se 
  encuentre en el scope local, pero si no es encontrado allÃ­, seguirÃ¡ la bÃºsqueda en el siguiente 
  outer scope. Y nuevamente, si no lo encuentra ahÃ­ buscarÃ¡ en el siguiente outer scope. Hasta llegar
  al scope global, si fuera necesario.

  Identifier lookup y el scope chain son dos herramientas poderosas para una funciÃ³n acceder a 
  identificadores en el cÃ³digo.
  De hecho vamos a hacer algo interesante: crear una funciÃ³n, empaquetarla con algunas variables y
  guardarla para acceder luego. Si tienes 5 botones en pantalla podrÃ­amos escribir 5 diferentes handlers
  o usar el mismo cÃ³digo 5 veces con difierentes valores.

  function remember(number){
    return function(){
      return number;
    }
  }

  const returnedFunction = remember(5);
  console.log(returnedFunction());

  Cuando el motor de JS entra en remember() crea un nuevo scope de ejecuciÃ³n que apunta al
  scope prioritario de ejecuciÃ³n. Este nuevo scope incluye una referencia al parÃ¡metro number,
  un Number inmutable de valor 5. Cuando el motor alcanza la funciÃ³n anidada, una funciÃ³n expresiÃ³n,
  aracha un link al scope de ejecuciÃ³n actual.

  Este proceso de la funciÃ³n de retener el acceso a su scope se llama closure. En este ejemplo,
  la funciÃ³n anidada cierra sobre number. Una closure puede capturar cualquier nÃºmero de parÃ¡metros
  y variables que necesita. MDN define un closure como:
  La combinaciÃ³n de una funciÃ³n y de un ambiente lÃ©xico en el cual la funciÃ³n fue declarada.

  Esta definiciÃ³n puede que no tenga mucho sentido si no entiendes el significado de ambiente lÃ©xico.
  El ES5 spec refiere al ambiente lÃ©xico como:
  La asociaciÃ³n de identificadores a variables especÃ­ficas y funciones basadas en la estructura lÃ©xica
  anidada de ECMAScript code.

  En este caso, el lexical environment refiere al cÃ³digo tal como fue escrito en el JS file. Entonces,
  el closure es:
  - Una funciÃ³n en sÃ­ misma
  - El cÃ³digo (pero mÃ¡s importante, la scope chain de) donde la funciÃ³n fue declarada.

  Cuando una funciÃ³n es declarada, se agarra a una scope chain. Lo que lo hace interesante es que sigue
  loqueada a esa scope chain aÃºn cuando invocamos la funciÃ³n en otro lugar del cÃ³digo.
  Closures nos permiten guardar una snapshot del estado en el momento en el que la funciÃ³n objeto fue 
  creada.

  Video
  â•â•â•â•â•
  1. Function
  2. Lexical environment

  Cada funciÃ³n tiene su propio closure y su propio scope. Lo que lo hace poderoso es cuando una funciÃ³n
  es retornada desde otra funciÃ³n. Esa funciÃ³n es declarada en una funciÃ³n, pero es retornada y corrida
  desde fuera de donde fue declarada, manteniendo su acceso a todo el scope en el que fue declarada. 

  Creating a Closure
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Cada vez que una funciÃ³n es definida, un closure es creado para esa funciÃ³n. Estrictamente hablando,
  cada funciÃ³n tiene closure. Esto es porque las funciones cierran sobre al menos un otro contexto
  a lo largo del scope chain: el scope global. Como sea, las capacidades de cierre realmente brillan 
  cuando trabajan con funciones anidadas, una funciÃ³n definida dentro de otra funciÃ³n.

  Recordar que una funciÃ³n anidada tiene acceso a las variables fuera de ella. Por lo que hemos aprendido
  del scope chain, esto incluye las variables del exterior, que encierra la propia funciÃ³n, la funciÃ³n padre.
  Estas funciones anidadas cierran sobre, capturan variables que no fueron pasadas como argumentos o 
  definidas localmente, conocidas como free variables.

  Como vimos en remember() es importante notar que la funciÃ³n mantienen una referencia al scope padre. Si
  la referencia a esa funciÃ³n todavÃ­a es accesible, el scopoe persiste.

  Closures and Scope
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Estos dos conceptos estÃ¡n tan estrechamente relacionados, que estuvimos trabajando con ellos todo el tiempo.
  Repasemos:

  const myName = 'Andrew';

  function introduceMyself() {
    const you = 'student';

    function introduce() {
      console.log(`Hello, ${you}, I m ${myName}!`);
    }

    return introduce();
  }

  introduceMyself();
  // 'Hello, student, I m Andrew!'

  Para recapitular: myName es variable definida fuera de una funciÃ³n, por lo tanto es una variable
  global en el scope global. En otras palabras, estÃ¡ disponible para ser usada por todas las funciones.

  En el caso de you, es referenciada por introduce() aunque no fue declarada dentro de ella. Esto es
  posible porque el scope de las funciones anidadas incluye variables declaradas dentro de la funciÃ³n
  que la anida. 

  Como resultado, introduce() y su ambiente lÃ©xico forman un closure. De esta manera introduce() tiene
  acceso no sÃ³lo a la variable global myName sino tambiÃ©n a la variable you, que fue declarada en el 
  scope de su funciÃ³n padre, introduceMyself()

  Ejercicio
  â•â•â•â•â•â•â•â•â•
  What is the output when result(10); is executed?

  function outerFunction() {
    let num1 = 5;

    return function(num2) {
      console.log(num1 + num2);
    };
  }

  let result = outerFunction();

  result(10);
  // 15

  Video
  â•â•â•â•â•
  function myCounter(){
    let count = 0;

    return function(){
      count +=1;
      return count;
    }
  }

  Tenemos la funciÃ³n myCounter() que utiliza el closure para crear un estado privado.
  Primero, tenemos una variable local, count establecida en 0.
  Luego myCounter retorna una funciÃ³n que incrementa de a 1 y retorna el contador.
  Lo copado de esto, es que la funciÃ³n anidada tiene un estado privado y mutable,
  pero no puede ser accedida externamente porque cierra sobre la variable counter.

  Voy a invocar el contador y guardar el valor en una variable que va a llamar al contador.

  let counter = myCounter();
  counter();

  Applications of Closures
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  To recap, we ve seen two common and powerful applications of closures:
  - Passing arguments implicitly.
  - At function declaration, storing a snapshot of scope.

  Ejercicio
  â•â•â•â•â•â•â•â•â•
  /*
  Declare a function named `expandArray()` that:
  * Takes no arguments
  * Contains a single local variable, `myArray`, which points to [1, 1, 1]
  * Returns an anonymous function that directly modifies `myArray` by
    appending another `1` into it
  * The returned function then returns the value of `myArray`
  */

  function expandArray(){
      let myArray = [1, 1, 1];
      
      return function(){
          myArray.push(1)
          return myArray;
      }
  }

  const callArray = expandArray();
  console.log(callArray());

  Garbage Collection
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  JS maneja memoria con una colecciÃ³n automÃ¡tica de basura. Esto quiere decir que cuando la data
  ya no es referible (no quedan mÃ¡s referencias que apunten a esa data en un cÃ³digo ejecutable)
  es recolectada y destruida en un punto mÃ¡s adelante en el tiempo. Esto libera recursos, por ej
  memoria ram, para que la data una vez consumida, los recursos puedan liberarse y reutilizarse.

  Summary
  â•â•â•â•â•â•â•
  Closure refiere a la combinaciÃ³n de una funciÃ³n con su ambiente lÃ©xico en el cual esa funciÃ³n
  fue declarada. Cada vez que una funciÃ³n es definida, closure es creado para esa funciÃ³n. 
  Esto es especialmente poderoso en situaciones donde una funciÃ³n es definida dentro de otra
  funciÃ³n, permitiendo a la funciÃ³n anidada acceder a variables fuera de ella. Las funciones
  tambiÃ©n mantienen enlace con los scopes padres aÃºn si el padre ha vuelto. Esto previene que la 
  data en sus padres sea recolectada como basura.

  Further Research
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - Memory Management on MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management
  - Closures on MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures
  - Lexical Environments in the ES5 spec: http://es5.github.io/#x10.2

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  2.5. Immediately-Invoked Function Expressions (IIFE)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Function Declarations vs. Function Expressions
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Declaration: define una funciÃ³n y no requiere que una variable sea asignada a ella. Simplemente
  declara una funciÃ³n y no devuelve un valor por sÃ­ misma. 

  function returnHello() {
    return 'Hello!';
  }

  Expression: retorna un valor. Las expresiones pueden ser anÃ³nimas o nombradas y son parte de la
  sintaxis de otra expresiÃ³n. Son comunmente asignadas a variables tambiÃ©n. 

  const myFunction = function(){
    return 'Hello!';
  }

  const myFunction = function returnHello(){
    return 'Hello!';
  }

  IIFE: Una funciÃ³n que es invocada inmediatamente despuÃ©s de su definiciÃ³n.

  Imaginemos la declaraciÃ³n de una funciÃ³n:

  function logger() {
    console.log('Hello there!');
  }

  La podemos convertir en expresiÃ³n rÃ¡pidamente, envolviÃ©ndola entre parÃ©ntesis:
  (function logger() {
    console.log('Hello there!');
  });

  Si le agregamos un par de parÃ©ntesisal terminar, la funciÃ³n serÃ¡ llamada justo despuÃ©s de ser 
  definida:
  (function logger() {
    console.log('Hello there!');
  })();

  Immediately-Invoked Function Expressions: Structure and Syntax
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  (function sayHi(){
    alert('Hi there!');
  })();

  La estructura sintÃ¡ctica de esta funciÃ³n puede parecer un poco extraÃ±a, pero lo que hicimos fue
  sÃ³lo envolverla entre parÃ©ntesis y agregar otro par de parÃ©ntesis al final.

  Passing arguments into IIFEs
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  (function (name){
      alert(`Hi, ${name}`);
    }
  )('Andrew');

  El segundo par de parÃ©ntesis no sÃ³lo ejecuta inmediatamente la funciÃ³n precedente, sino que toma
  los argumentos que la funciÃ³n pueda necesitar.

  (function (x, y){
      console.log(x * y);
    }
  )(2, 3);
  // 6

  IIFEs and Private Scope
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Uno de los usos primarios de las IIFEs es crear scopes privados. Recordar que las variables en JS
  son tradicionalmente scoped a una funciÃ³n. Sabiendo esto podremos aprovechar el comportamiento de 
  closures para proteger variables o mÃ©todos de ser accedidos. 

  const myFunction = ( // IIFE desde parÃ©ntesis hasta el final
      function () { 
          const hi = 'Hi!'; // Var disponible para el retorno de la fc
          return function () { // fc anÃ³nima retornada de myFunction
              console.log(hi);
          }
      }
  )();

  La IIFE es usada para retornar inmediatamente una funciÃ³n. Esta funciÃ³n corre y retorna una funciÃ³n
  anÃ³nima que es almacenada en la variable myFunction.

  La funciÃ³n que retorna captura la variable hi. Esto permite que myFunction mantenga un estado privado
  y mutable, que no puede ser accedido por fuera de la funciÃ³n.
  Y mÃ¡s aÃºm, debido a que la funciÃ³n expresada es llamada inmediatamente, la IIFE envuelve el cÃ³digo de
  manera que no se ensucia el global scope.

  What is true about immediately-invoked function expressions?
    IIFEs can be used to create private scope
    IIFEs are very closely associated with scope and closures
    There is an alternative syntax for writing an IIFE

  ğŸ’¡ Alternative Syntax for IIFEs ğŸ’¡
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  (function sayHi(){
    alert('Hi there!');
  }
  )();
  // alerts 'Hi there!'

  Esto funciona bÃ¡rbaro pero existen otras formas de escribir esto para alcanzar mejores resultados.
  El cierre del primer set de parÃ©ntesis podemos moverlo al final:

  (function sayHi(){
    alert('Hi there!');
  }());
  // alerts 'Hi there!'

  Estas son formas estilÃ­sticas de ecribir, no hay una forma correcta de hacerlo. Ambos son acercamientos
  vÃ¡lidos para llegar al mismo resultado y el motor JS seguirÃ¡ parseÃ¡ndolos como expresiones funcionales,
  no como declaraciones.
  Douglas Crockford ha mencionado que envolver la unidad entera entre parÃ©ntesis ayuda a los lectores A
  comprender que lo que estÃ¡n viendo es una expresiÃ³n.

  https://www.youtube.com/watch?feature=player_detailpage&v=taaEzHI9xyY#t=2020s

  IIFEs, Private Scope, and Event Handling
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Vamos a ver otro ejemplo de un IFEE pero esta vez en contexto del manejo de un evento.
  Digamos que queremos crear un botÃ³n en una pÃ¡gina que alerte al usuario en cada otro click.
  Una forma de hacer esto, podrÃ­a ser trackear el nÃºmero de veces que un botÃ³n fue clickeado.
  Pero cÃ³mo mantenemos esta data?

  PodrÃ­amos trackear el contador con una variable que declaramos en el scope global, esto tiene
  sentido si otra parte de la app necesita acceder a esa data. De todas formas, un mejor approach
  serÃ­a encapsular esta data en un manejador de eventos en sÃ­.

  Por un lado, porque esto prevendrÃ­a de polucionar el ambiente global con variables extras (y 
  potencialmente colisiones de nombres de variables). Y es mÃ¡s, si usamos una IIFE podemos aprovechar
  el cierre para proteger el contador de ser accedido externamente. Esto prevendrÃ­a cualquier 
  mutaciÃ³n accidental o efectos colaterales no queridos por alterar el contador inadvertidamente.

  <!-- button.html -->
  <html>
    <body>
      <button id='button'>Click me!</button>
      <script src='button.js'></script>
    </body>
  </html>

  // button.js
  const button = document.getElementById('button');

  button.addEventListener('click', (function() { // FunciÃ³n que retorna una funciÃ³n
    let count = 0; // Creamos una variable local

    return function() { // Retornamos una funciÃ³n
      count += 1; // Incrementa count

      if (count === 2) { // Pero, cuando llega a 2
        alert('This alert appears every other press!'); // Alerta al usuario 
        count = 0; // Y vuelve el contador a cero
      }
    };
  })());

  Lo que es importante para notar es que la funciÃ³n retornada se cierra sobre la variable count.
  Esto es porque la funciÃ³n mantiene una referencia sobre el ambiente padre. count estÃ¡ disponible
  para la funciÃ³n retornada para su uso. Como resultado inmediatamente invocamos una funciÃ³n que 
  retorna esa funciÃ³n. Y como la funciÃ³n retornada tiene acceso a la varibale interna count, un
  ambiente privado es creado, efectivamente protegiendo la data.

  Ejercicio
  â•â•â•â•â•â•â•â•â•
  (function(n){
      delete n;
      return n;
  })(2);
  // 2

  Este puede ser un poco tramposo. La clave en este ejercicio es el operador delete. Este operador
  sÃ³lo es efectivo sobre propiedades de objetos, no puede ser usado para desasignar recursos 
  directamente. No tiene efecto sobre variableso nombre de funciones.
  Es por eso que este ejercicio tiene 2 como resultado.

  Benefits of Immediately-Invoked Function Expressions
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Como hemos visto, usando funciones expresivas inmediatamente invocadas crea ambientes privados
  que protegen las variables o mÃ©todos de ser accedidos. IIFEs, por Ãºltimo, usan funciones
  retornadas para acceder a data privada que se encuentra dentro del cierre. Esto funciona muy bien,
  mientras estas funciones son retornadas para acceso pÃºblico, aÃºn mantienen la privacidad para las 
  variables declaradas dentro de ellas.

  Otra gran oportunidad para usar las IIFEs es cuando quieren ejecutar cierto cÃ³digo sin crear variables
  globales extra. Sin embargo, notemos que una IIFE se espera que sÃ³lo sea invocada una vez, para crear
  un Ãºnico contexto de ejecuciÃ³n. Si tenemos un cÃ³digo que esperamos volver a utilizar, declarar la funciÃ³n
  y luego invocarla serÃ­a la mejor opciÃ³n.

  Si tienes una tarea de una sÃ³la vez, como ser inicilizar la aplicaciÃ³n, an IIFE es una gran manera de
  hacerlo sin polucionar el ambiente global con variables extras. Mantener limpio el espacio de nombres 
  globales reduce la posibilidad de colisiones con nombres de variables duplicadas, etc.

  Summary
  â•â•â•â•â•â•â•
  Una IIFE es una funciÃ³n llamada inmediatamente luego de que es definida. Su utilizaciÃ³n permite 
  ambientes privados, lo que mantiene la privacidad de las variables definidas dentro de ellas. 
  Esto permite mantener el ambiente global limpio.

  Further Research
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - Function Declarations vs. Function Expressions: https://javascriptweblog.wordpress.com/2010/07/06/function-declarations-vs-function-expressions/
  - An Introduction to IIFEs - Immediately Invoked Function Expressions on A Drip of JavaScript: http://adripofjavascript.com/blog/drips/an-introduction-to-iffes-immediately-invoked-function-expressions.html
  - Immediately-Invoked Function Expression (IIFE) by Ben Alman: http://benalman.com/news/2010/11/immediately-invoked-function-expression/

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  2.6. Summary
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Aprendimos:
  - First-Class Functions
  - Functions as values
  - High-order Functions
  - Callback Functions
  - Functions as arguments
  - Scopes
  - Closures
  - Scope-chains
  - IIFEs
