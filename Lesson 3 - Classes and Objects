â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘   Object-Oriented JavaScript  â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  3. Class and Objects
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  3.1. IntroducciÃ³n
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Hasta ahora construimos one off objects (objetos Ãºnicos). Para construir aplicaciones mÃ¡s
  estructuradas necesitamos saber cÃ³mo construir clases o categorÃ­as de objetos.

  En esta secciÃ³n veremos:
  - cÃ³mo crear nuevos objetos con funciones constructoras
  - el uso de this para crear y acceder a propiedades de objetos
  - prototypal inheritance and subclassing

  Propiedades y MÃ©todos
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Como un objeto puede representar data y funcionalidades, podemos usar un objeto para expresar
  cosas reales, personas u objetos, en cÃ³digo.
  
  Ejercicio libre
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  let lamp = {
    type: 'desktop',
    color: 'grey',
    light: 'soft',
    state: 'on',
    switch: function(){
      if(this.state === 'off'){
        return this.state = 'on'
      } else { 
        return this.state = 'off'
      }
    }
  }

  console.log(lamp.switch());

  Ejercicio
  â•â•â•â•â•â•â•â•â•
  Mirar objetos alrededor y ver cÃ³mo serÃ­a mejor clasificarlos y agruparlos.

  DecoraciÃ³n:
    Cuadros
    LÃ¡mapara
    Escritorio
    Silla
    Espejo
    Biblioteca
    Cajonera
  
  Libros

  Plantas:
    Pothus

  Arte:
    Instrumentos musicales:
      Guitarra

    Materiales pintura:
      Bastidores
      AcrÃ­licos
      Pinceles
  
  Estudios:
    Apuntes
    Fotocopias
    Libros

  Dispositivos electrÃ³nicos:
    Compu
    Celu

  Summary
  â•â•â•â•â•â•â•
  Los objetos en JS representan cosas de la realidad. 
  Tienen propiedades para representar atributos.
  Tienen mÃ©todos para representar acciones que pueden realizar.
  Podemos pensar los objetos como sustantivos: dog / car
  Los valores de las propiedades como adjetivos: blue
  Y los mÃ©todos como verbos: drive / bark

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  3.2. Constructor Functions
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•  
  Hay tres formas de crear un objeto:
  - utilizando literal notation
  - creando una funciÃ³n que retorne un objeto
  - utilizando una funciÃ³n constructora

  Una funciÃ³n constructora es similar a una funciÃ³n que retorna un objeto pero tiene algunas
  diferencias:
  1. Una funciÃ³n constructora comienza con mayÃºscula
  2. Una funciÃ³n constructora siempre debe llamarse con la keyword new
  3. Mientras una funciÃ³n regular debe crear el objeto que va a retornar y modificarlo 
  directamente, la funciÃ³n constructora crea su objeto automÃ¡ticamente. Luego para agregar 
  propiedades o mÃ©todo a ese objeto tenemos que utilizar this 

  Para instanciar un nuevo objeto utilizamos el operador new para invocar la funciÃ³n:
  new SoftwareDeveloper();

  El que el nombre del objeto comience en mayÃºscula, es una convenciÃ³n entre desarrolladores,
  no es un requisito del lenguaje.

  Lo que a una funciÃ³n constructora la determina como tal es:
  - El uso del operador new para invocar la funciÃ³n
  - CÃ³mo la funciÃ³n estÃ¡ escrita internamente

  Constructor Functions: Structure and Syntax
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  internamente se ve asÃ­:

  function SoftwareDeveloper() {
    this.favoriteLanguage = 'JavaScript';
  }

  A diferencia de las variables en las funciones constructoras la persistencia de datos se
  hace con this.
  La funciÃ³n de arriba agregarÃ¡ favoriteLanguage al objeto que crea, y asigna como valor
  por defecto 'JavaScript'.
  this refiere al objeto que fue creado usando new frente a la funciÃ³n constructora. 
  Las funciones constructoras no retornar valores, no retornan nada explÃ­citamente, no deben
  tener un return statement.

  Creating a New Object
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  function SoftwareDeveloper(){
    this.favoriteLanguage = 'JavaScript';
  }

  let developer = new SoftwareDeveloper();

  console.log(developer);

  Retorna 
  â–¼ SoftwareDeveloper { favoriteLanguage: 'JavaScript' }
    â–¼ __proto__: 
      â–¶ constructor: Æ’ SoftwareDeveloper()

  Hacemos otro con literal notation y comparamos lo que retorna:

  let otherDeveloper = { favoriteLanguage: 'JavaScript' };
  
  console.log(otherDeveloper);

  Retorna 
  â–¼ { favoriteLanguage: 'JavaScript' }
    â–¼ __proto__: 
      â–¶ constructor: Æ’ Object()


  Creating Multiple Objects
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  Podemos utilizar la misma funciÃ³n constructora como querramos. Invoquemos la funciÃ³n
  algunas veces mÃ¡s, para crear nuevos objetos:

  let engineer = new SoftwareDeveloper();
  let programmer = new SoftwareDeveloper();

  console.log(engineer);
  // SoftwareDeveloper { favoriteLanguage: 'JavaScript' }
  console.log(programmer);
  // SoftwareDeveloper { favoriteLanguage: 'JavaScript' }

  Constructor Functions Can Have Parameters
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Uno de los beneficios de las funciones constructoras es que aceptan argumentos. 
  Actualicemos el constructor para que acepte un argumento y asignÃ©mosle la propiedad 
  name.

  function SoftwareDeveloper(name){
    this.favoriteLanguage = 'JavaScript';
    this.name = name;
  }

  let instructor = new SoftwareDeveloper('Andrew');
  console.log(instructor);
  // SoftwareDeveloper { favoriteLanguage: 'JavaScript', name: 'Andrew' }

  let teacher = new SoftwareDeveloper('Richard');
  console.log(teacher);
  // SoftwareDeveloper { favoriteLanguage: 'JavaScript', name: 'Richard' }

  Preguntas
  â•â•â•â•â•â•â•â•â•
  Which of the following about constructor functions are true? 
  - must be invoked with new
  - are used to instantiate a new object

  What happens if a constructor function begins with a lower-case letter?
  - Nothing, it will still work.

  Ejercicio
  â•â•â•â•â•â•â•â•â•
  Declare a `Sandwich` constructor function that takes three parameters:
  1. `bread` (string) - the type of bread for the sandwich (e.g. "Wheat")
  2. `meat` (array) - the meats to put on the sandwich (e.g. `[]` for a vegetarian sandwich!)
  3. `vegetables` (array) - the vegetables to include in the sandwich

  function Sandwich(bread, meat, vegetables){
      this.bread = bread;
      this.meat = meat;
      this.vegetables = vegetables;
  }

  let lomitoCompleto = new Sandwich('Pan negro', ['lomito ahumado', 'queso'], ['tomate', 'lechuga']);

  console.log(lomitoCompleto);

  /* 
  Sandwich {
  bread: 'Pan negro',
  meat: [ 'lomito ahumado', 'queso' ],
  vegetables: [ 'tomate', 'lechuga' ] } 
  */

  âš ï¸ Omitting the new Operator âš ï¸
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  QuÃ© pasarÃ­a si inadvertidamente invocÃ¡s un constructor sin el operador new? El objeto
  no se crearÃ­a, la funciÃ³n serÃ­a invocada como cualquier otra funciÃ³n regular y lo 
  retornado serÃ¡ undefined y el valor de this es completamente diferente.

  function SoftwareDeveloper(name) {
    this.favoriteLanguage = 'JavaScript';
    this.name = name;
  }

  let coder = SoftwareDeveloper('David');

  console.log(coder);
  // undefined

  Seeing the Object s Constructor (instanceof)
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function Developer(name){
    this.name = name;
  }

  const dev = new Developer('Andrea');

  typeof dev;
  "Object" // Nos confirma que es un objeto

  dev instanceof Developer;
  true // Nos confirma que dev es una instancia de Developer

  ğŸ’¡ instanceof and the Prototype Chain ğŸ’¡
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  En el ejemplo anterior resulta sencilla la confirmaciÃ³n de dev como instancia de 
  Developer porque estÃ¡ directamente instanciado.
  Cuando se tratan de cadenas de prototipos el test puede dificultarse, chequearÃ¡
  si el constructor aparece o no en la cadena de prototipos, pero no sabremos siempre
  exactamente quÃ© constructor es el que creÃ³ el objeto, pero sÃ­ nos podrÃ¡ decir a quÃ©
  propiedades y mÃ©todos ese objeto tendrÃ¡ acceso.

  Ejercicio
  â•â•â•â•â•â•â•â•â•
  function Finch(name) {
    this.kingdom = 'Animalia';
    this.name = name;
  }

  function Sparrow(name) {
    this.kingdom = 'Animalia';
    this.name = name;
  }

  const atticus = new Finch('Atticus');
  const jack = new Sparrow('Jack');

  What is the result when atticus instanceof Sparrow; // false

  Summary
  â•â•â•â•â•â•â•
  El sistema de clases de JS se construye directamente sobre el uso de funciones y 
  objetos. Llamando a una funciÃ³n constructora con el operador new podemos instanciar
  nuevos objetos. El mismo constructor podemos utilizarlo para crear diferentes 
  objetos.

  Further Research
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - The new operator on MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new
  - The instanceof operator on MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  3.3. The 'this' keyword
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Functions â‡” Objects â‡” this
  Cuando una funciÃ³n es llamada la variable this es seteada a un objeto especÃ­fico.
  El valor de this va a depender cÃ³mo fue llamada la funciÃ³n.
  Vamos a ver diferentes formas de llamar funciones y ver cÃ³mo se comporta this.

  this in Constructor Functions
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function Cat(name) {
    this.name = name;
    this.sayName = function () {
      console.log(`Meow! My name is ${this.name}`);
    };
  }

  const bailey = new Cat('Bailey');

  When is this Assigned?
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Uno de los errores mÃ¡s comunes es creer que this refiere al objeto en el que fue creado.
  En realidad no es asignado a nada hasta que el mÃ©todo es llamado, donde this sea usado.
  El valor asignado a this se basa en el objeto que invoca el mÃ©todo donde this es definido.

  const dog = {
    bark: function () {
      console.log('Woof!');
    },
    barkTwice: function () {
      this.bark();
      this.bark();
    }
  };
  dog.bark();
  // Woof!

  dog.barkTwice();
  // Woof!
  // Woof!

  Cuando llamamos a this.bark o this.barkTwice, this se setea. Como this puede acceder al 
  objeto que lo creÃ³, barkTwice tambiÃ©n puede acceder al objeto dog.
  QuÃ© pasa si sÃ³lo escribimos bark() sin this en barkTwice? BuscarÃ¡ una variable local con
  ese nombre y no la encontrarÃ¡, la buscarÃ¡ en el siguiente outer scope, no lo encontrarÃ¡.

  Ejercicio
  â•â•â•â•â•â•â•â•â•
  What is true about this? Select all that apply:
  - Using this, methods can access and manipulate an object s properties
  - this is a reserved word in JavaScript


  - Consider the following constructor function, City:

  function City(name, population) {
    this.name = name;
    this.population = population;

    this.identify = function () {
      console.log(`${this.name} s population is ${this.population}.`);
    };
  }

  const sanFrancisco = new City('San Francisco', 870000);

  What is the value of this?
  - City NO
  - El objeto reciÃ©n creado, referenciado por San Francisco SI

  What Does this Get Set To?
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Entonces, this en diferentes contextos:
  - dentro de un mÃ©todo
  - siendo referenciado por una funciÃ³n constructora

  Hay cuatro formas de llamar funciones y cada una de ellas setea this de manera diferente:
  1. Llamando a una funciÃ³n constructora con new, this se setea dentro del objeto nuevo, 
  reciÃ©n creado. Es decir, no apunta a City, sino a San Francisco.

  2. Al llamar a una funciÃ³n que pertenece a un objeto, un mÃ©todo, setea el this
  al objeto mismo. El mÃ©todo barkTwice() tenÃ­a acceso a las propiedades de dog en sÃ­ misma.

  3. Llamando a una funciÃ³n por sÃ­ misma, invocando a la funciÃ³n regular, setearÃ¡ this a
  window, que es el objeto global en el ambiente del browser host.

  function funFunction() {
    return this;
  }

  funFunction();
  // (returns the global object, `window`)

  4. Permite setear this nosotros mismos. 

  â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
  â•‘ Call Style    â•‘ 'new'       â•‘ method           â•‘ function      â•‘ custom        â•‘
  â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
  â•‘ 'this'        â•‘ {}          â•‘ object itself    â•‘ global object â•‘               â•‘     
  â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
  â•‘ Example       â•‘ new Cat()   â•‘ bailey.sayName() â•‘ introduce()   â•‘               â•‘
  â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• 

  Ejercicio
  â•â•â•â•â•â•â•â•â•
  const building = {
    floors: 5,
    addFloor: function () {
      this.floors += 1;
    }
  };

  building.addFloor();
  // this is pointing to building

  --

  function myFunction() {
    console.log("What is the value of 'this'?");
  }

  myFunction();
  // the value of this is window

  Summary
  â•â•â•â•â•â•â•
  Funciones, objetos y this estÃ¡n todos interconectados. Cuando invocamos un constructor
  con el operador new, una variables this se setea al objeto nuevo reciÃ©n creado.
  Cuando invocamos un mÃ©todo, this es seteado para el objeto en sÃ­ mismo.
  Y cuando invocamos una funciÃ³n en el ambiente navegador, this es seteado a window, el
  objeto global.

  Further Research
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - The this operator on MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  3.4. Setting our own 'this'
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Para setear el valor de this nosotros mismos, JS nos ofrece algunos mÃ©todos para hacerlo.
  - call() - method on a function
  - apply() - method on a function
  - bind() - method thar returns a new function
  
  Son utilizados en diferentes contextos.
  
  More Ways to Invoke Functions
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  call() y apply()
  Cada mÃ©todo puede ser directamente invocado sobre una funciÃ³n en sÃ­ misma. Como resultado,
  la funciÃ³n que recibe serÃ¡ invocada con un valor this especÃ­fico, tanto como cuantos 
  argumentos le sean pasados.

  call()
  â•â•â•â•â•â•
  Es un mÃ©todo directamente invocado sobre una funciÃ³n. Primero pasamos en Ã©l un valor para
  setear el valor de this. DespuÃ©s le pasamos en cualquiera de las funciones receptoras, los
  argumentos, uno a uno, separados por comas.

  function multiply(n1, n2) {
    return n1 * n2;
  }

  multiply(3, 4);
  // 12

  multiply.call(window, 3, 4);
  // 12

  - Invocamos el mÃ©todo call directamente sobre multiply()
  - No es seguido de parÃ©ntesis
  - call() manejarÃ¡ la invocaciÃ³n y sus argumentos
  - El primer argumento es el valor seteado a this
  - Los otros argumentos son los que toma la funciÃ³n multiply(), individualmente separados
  por comas

  CÃ³mo invocamos funciones attach a objetos? Al usar call() para invocar mÃ©todos nos 
  permite pedir prestado un mÃ©todo de un objeto para ser utilizado en otro objeto.

  const mockingbird = {
    title: 'To Kill a Mockingbird',
    describe: function () {
      console.log(`${this.title} is a classic novel`);
    }
  };

  mockingbird.describe(); // 'To Kill a Mockingbird is a classic novel'

  const pride = {
    title: 'Pride and Prejudice'
  };

  mockingbird.describe.call(pride); // 'Pride and Prejudice is a classic novel'

  - call() invoca mockingbird.describe que apunta a una funciÃ³n
  - El valor de this es pasado dentro de call(): pride
  - mockingbird.describe referencia this.title, por lo que necesitamos acceder a la 
  propiedad title del objeto al que hace referencia this.
  - Como seteamos nuestro propio valor de this, el valor de this.title serÃ¡ accedido
  desde el objeto pride.

  call() nos sirve para los casos en que buscamos invocar una funciÃ³n en el scope del
  primer argumento que le pasamos.

  apply()
  â•â•â•â•â•â•â•
  En vez de pasar los argumentos separados por coma, apply recibe un array.

  function multiply(n1, n2) {
    return n1 * n2;
  }

  multiply.call(window, 3, 4); // 12

  multiply.apply(window, [3, 4]); // 12

  El primer argumento sigue siendo el valor a setear para this. Ahora quÃ© pasa con los
  mÃ©todos y objetos?

  const mockingbird = {
    title: 'To Kill a Mockingbird',
    describe: function () {
      console.log(`${this.title} is a classic novel`);
    }
  };

  const pride = {
    title: 'Pride and Prejudice'
  };
  
  mockingbird.describe.call(pride); // 'Pride and Prejudice is a classic novel'

  mockingbird.describe.apply(pride); // 'Pride and Prejudice is a classic novel'

  Both approaches produce the same result.

  Choosing One Method Over the Other
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  call() puede limitarnos cuando no sabemos la cantidad de argumentos que necesita
  la funciÃ³n. En este caso apply() serÃ¡ una mejor opciÃ³n. Desempaca los argumentos
  en el array y los pasa.

  // Tenemos un objeto
  let cat = {
    name: 'Bailey'
  }
  
  // Y una funciÃ³n con un valor this
  function sayHello(message){
    console.log(`${message}, ${this.name}`)
  }

  sayHello.call(cat, 'Hi'); // Hi, Bailey

  sayHello.apply(cat, ['Hello']); // Hello, Bailey


  Ejercicio
  â•â•â•â•â•â•â•â•â•
  const dave = {
    name: 'Dave'
  };

  function sayHello(message) {
    console.log(`${message}, ${this.name}. You re looking well today.`);
  }

  Let s say you want the message 'Hello, Dave. You re looking well today.' printed 
  to the console. 
  // sayHello.apply(dave, ['Hello']);

  Ejercicio
  â•â•â•â•â•â•â•â•â•
  Consider the following Andrew and Richard objects:

  const Andrew = {
    name: 'Andrew',
    introduce: function () {
      console.log(`Hi, my name is ${this.name}!`);
    }
  };

  const Richard = {
    name: 'Richard',
    introduce: function () {
      console.log(`Hello there! I m ${this.name}.`);
    }
  };

  When Richard.introduce.call(Andrew) is executed, what is logged to the console?
  // Hello there! I m Andrew.

  Ejercicio
  â•â•â•â•â•â•â•â•â•
  const andrew = {
    name: 'Andrew'
  };

  function introduce(language) {
    console.log(`I m ${this.name} and my favorite programming language is ${language}.`);
  }

  Write an expression that uses the call() method to produce the message: 
  'I m Andrew and my favorite programming language is JavaScript.'

  // introduce.call(andrew, 'JavaScript');

  Callbacks and this
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Con callbacks se vuelve un poco tricky. 

  function invokeTwice(cb) {
    cb();
    cb();
  }

  const dog = {
    age: 5,
    growOneYear: function () {
      this.age += 1;
    }
  };

  dog.growOneYear();  // this works as expected 5 to 6
  dog.age; // 6

  invokeTwice(dog.growOneYear); // undefined
  dog.age; // 6

  Esto pasa porque this hace referencia al objeto window.

  Saving this with an Anonymous Closure
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Cuando pasamos como argumento growOneYear la estamos pasando como funciÃ³n y no 
  como mÃ©todo. Esto hace que el this tenga valor window y no dog, como quisiÃ©ramos.

  Saving this with an Anonymous Closure
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Una forma de resolver esto es usando un closure anÃ³nimo sobre el objeto dog:

  invokeTwice(function () { 
    dog.growOneYear(); 
  });

  dog.age; // 7

  Saving this with bind()
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Como este es un patrÃ³n comÃºn, JS nos provee el mÃ©todo bind(). Es similar a call y 
  apply, pero nos permite definir directamente un valor para this. Es un mÃ©todo que
  tambiÃ©n se llama sobre una funciÃ³n, pero a diferencia de los otros, bind retorna
  una nueva funciÃ³n quem cuando es llamada, tiene this con el valor que le hemos 
  seteado.

  function invokeTwice(cb) {
    cb();
    cb();
  }

  const dog = {
    age: 5,
    growOneYear: function () {
      this.age += 1;
    }
  };

  invokeTwice(dog.growOneYear); 
  // Esto nos devolverÃ¡ undefined porque growOneYear apunta al objeto window

  const myGrow = dog.growOneYear.bind(dog); 
  // A travÃ©s de bind seteamos el valor de this para cuando utilicemos growOneYear
  // Esto retorna una nueva funciÃ³n que hace que growOneYear ahora haga referencia al objeto dog
  // y ya no a window

  invokeTwice(myGrow);
  // FuncionarÃ­a como el clousure anÃ³nimo

  dog.age; // 7

  Question
  â•â•â•â•â•â•â•â•
  What is true about bind()?
  - bind() is a method that is called on a function
  - bind() returns a new function that, when called, has this set to the provided object

  Ejercicio
  â•â•â•â•â•â•â•â•â•
  Consider the following:

  const driver = {
    name: 'Danica',
    displayName: function () {
      console.log(`Name: ${this.name}`);
    }
  };

  const car = {
    name: 'Fusion'
  };

  Write an expression using bind() that allows us to "borrow" the displayName() method 
  from driver for the car object to use. Note: The expression itself is sufficient (no 
  need to save it to a variable).
  // driver.displayName.bind(car);

  Summary
  â•â•â•â•â•â•â•
  JS nos provee de tres mÃ©todos que nos permiten setear el valor de this para una funciÃ³n:
  - call() invoca la funciÃ³n y sus argumentos, pasados individualmente separados por comas.
  - apply() invoca la funciÃ³n y sus argumentos, pasados en un array.
  - bind() retorna una nueva funciÃ³n con this conectado a un objeto especÃ­fico, permitiÃ©ndonos
  llamarla como una funciÃ³n regular.

  Further Research
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - Kyle Simpson s You Don t Know JS: https://github.com/getify/You-Dont-Know-JS/blob/master/this%20&%20object%20prototypes/README.md#you-dont-know-js-this--object-prototypes
  - call() on MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call
  - apply() on MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply
  - bind() on MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  3.5. Prototypal Inheritance
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Herencia o extensiÃ³n, un objeto puede recibir las caracterÃ­sticas de otro objeto.
  
  Car() â†’ Prototype â†’ new â†’ car1 â†’ red
                    â†˜ new â†’ car2 â†’ blue
                    â†˜ new â†’ car3 â†’ green

  No sÃ³lo cada uno tiene sus propias propiedades, sino que estan ligadas a un objeto comÃºn
  llamado prototipo. Nosotros podemos agregar mÃ©todos al prototipo para que todos los new
  car puedan compartir.
  En vez de compartir un nuevo mÃ©todo para cada vez que un car es creado, cada car puede 
  compartir el mismo.
  En JS podemos aprovechar los prototipos para manejar la herencia.

  Adding Methods to the Prototype
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Recordemos que los objetos contienen data, propiedades. 
  AsÃ­ como los medios para manipular esa data, mÃ©todos.

  function Cat(name) {
    this.lives = 9;
    this.name = name;

    this.sayName = function () {
      console.log(`Meow! My name is ${this.name}`);
    };
  }

  De esta manera el mÃ©todo sayName se agrega a todos los objetos Cat guardando la funciÃ³n
  al atributo sayName al objeto reciÃ©n creado con new desde Cat.

  Esto funciona muy bien, pero quÃ© pasa si queremos instanciar mÃ¡s de un objeto Cat con
  este constructor? CrearÃ­amos una nueva funciÃ³n por cada vez que se instancie ese objeto.
  Es mÃ¡s, si quisieras realizar modificaciones sobre el objetom tendrÃ­as que modificar cada
  objeto individualmente. En esta situaciÃ³n tiene sentido tener creados todos los objetos
  desde el mismo constructor Cat que compartan el mismo mÃ©todo.

  Para ahorrar memoria y mantener las cosas limpias podemos agregar mÃ©todos al prototipo de
  la funciÃ³n constructora Cat.
  El prototipo es sÃ³lo un objeto y todos los objetos creados por una funciÃ³n constructora
  mantienen una referencia al prototipo. Esos objetos incluso pueden utilizar las propiedades
  del prototipo como si fueran suyas.

  JS aprovecha este enlace secreto entre el objeto y su prototipo para implementar la herencia.
  Consideremos la siguiente cadena prototÃ­pica:

                          â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—  â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—  â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
                          â•‘   constructor   â•‘  â•‘   constructor   â•‘  â•‘   constructor   â•‘
  â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—  new  â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£  â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£  â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
  â•‘    bailey     â•‘   â†µ   â•‘       Cat()     â•‘  â•‘     Animal()    â•‘  â•‘     Object()    â•‘
  â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£       â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•  â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•  â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• 
  â•‘    lives      â•‘                â”‹                    â”‹                    â”‹           â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
  â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•       â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—  â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—  â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—  â•‘    undefined    â•‘    
          â•¹               â•‘    prototype    â•‘  â•‘    prototype    â•‘  â•‘    prototype    â•‘  â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          â•¹               â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£  â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£  â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£           â•¹
          â”—â•ºâ•ºâ•ºâ•ºâ•ºâ•ºâ•ºâ•ºâ•ºâ•ºâ•ºâ•ºâ•ºâ•º â•‘      meow()     â•‘â•ºâ•ºâ•‘     kingdom     â•‘â•ºâ•ºâ•‘ hasOwnProperty()â•‘â•ºâ•ºâ•ºâ•ºâ•ºâ•ºâ•ºâ•ºâ•ºâ•ºâ•ºâ”› 
                          â•‘                 â•‘  â•‘  calculateAge() â•‘  â•‘ isPrototypeOf() â•‘
                          â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•  â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•  â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• 

  - Cat() constructor is invoke using new operator
  - new operator creates the bailey instance object
  - meow() method is defined in the prototype of bailey object s constructor function
  - prototype is just an object 
  - all objects created by that constructor are secretly linked to the prototype
  - podemos ejecutar bailey.meow() como si fuera su propio mÃ©todo

  Recordemos que cada funciÃ³n tiene una propiedad prototipo, que realmente es sÃ³lo un objeto.  
  Cuando una funciÃ³n es invocada como un constructor usando el operador new, crea y retorna un nuevo objeto.
  Este objeto estÃ¡ secretamente enlazado al prototipo de su constructor.
  Este enlace es el que le permite ustilizar propiedades y mÃ©todos del prototipo como si fueran propios.

  Como sabemos que la propiedad de un prototipo sÃ³lo apunta a un objeto regular, ese objeto en sÃ­ mismo
  tiene tambiÃ©n un enlace secreto a su prototipo. Y ese prototipo objeto tambiÃ©n tiene una referencia a su
  propio prototipo, y asÃ­ sucesivamente. AsÃ­ es cÃ³mo la cadena prototÃ­pica es formada.

  Finding Properties and Methods on the Prototype Chain
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Ya sea que estÃ©s queriendo acceder a una propiedad o a un mÃ©todo el intÃ©rprete de JS buscarÃ¡ por ellos
  a lo largo de la cadena prototÃ­pica en un orden muy particular:
  - Primero, buscarÃ¡ en las propiedades propias del objeto. Esto quiere decir que si propiedades o mÃ©todos
  fueron definidos en directamente en el objeto mismo esto tomarÃ¡ precedencia sobre cualquier otra propiedad
  o mÃ©todo en otro lado, si sus nombres son los mismos, similar a shadowing en la scope chain.
  - Si no encuentra, buscarÃ¡ en el prototipo del constructor del objeto para matchear.
  - Si no existe en el prototipo, seguirÃ¡ buscando en la cadena.
  - Al final de la cadena buscarÃ¡ en el Object() object, que es el mÃ¡s alto nivel padre. Si la propiedad aÃºn
  no es encontrada, la propiedad serÃ¡ indefinida.

  Previamente sÃ³lo definimos mÃ©todos directamente en el constructor. Veamos cÃ³mo se definen en el prototipo.

  function Dog(age, weight, name) {
    this.age = age;
    this.weight = weight;
    this.name = name;
  }

  Dog.prototype.bark = function () {
      console.log(`${this.name} says woof!`);
  };

  dog1 = new Dog(2, 60, 'Java');
  dog1.bark(); // Java says woof!

  Question
  â•â•â•â•â•â•â•â•
  // (A)
  function Dalmatian (name) {
    this.name = name;
    this.bark = function() {
      console.log(`${this.name} barks!`);
    };
  }

  // (B)
  function Dalmatian (name) {
    this.name = name;
  }
  Dalmatian.prototype.bark = function() {
    console.log(`${this.name} barks!`);
  };

  Let s say that we want to define a method that can be invoked on instances (objects) of the 
  Dalmatian constructor function (we ll be instantiating at least 101 of them!).
  Which of the preceding two approaches is optimal?
  (B) is optimal, because the function that bark points to does not need to be recreated each
  time an instance of Dalmatian is created.

  While both approaches work just fine (i.e., any instances created by the constructor function
  will be able to invoke a bark() method), the second approach is more ideal. By adding methods 
  to the prototype, memory is saved as more Dalmatian objects are instantiated. Along with being 
  more efficient, we also don t have to update all objects individually should be decide to 
  change a method.

  ğŸ’¡ Replacing the prototype Object ğŸ’¡
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  QuÃ© pasa si reemplazamos completamente la funciÃ³n prototÃ­pica de un objeto? 
  CÃ³mo afecta esto a los objetos creador por esa funciÃ³n?
  
  function Hamster() {
    this.hasFur = true;
  }

  let waffle = new Hamster();
  let pancake = new Hamster();

  Hamster.prototype.eat = function () {
    console.log('Chomp chomp chomp!');
  };

  waffle.eat();  // 'Chomp chomp chomp!'
  pancake.eat();  // 'Chomp chomp chomp!'

  Los objetos definidos anteriormente no tendrÃ¡n acceso a lo que agreguemos a continuaciÃ³n.
  SÃ³lo mantienen su lazo al viejo prototipo.

  Hamster.prototype = {
    isHungry: false,
    color: 'brown'
  };

  console.log(waffle.color); // undefined
  waffle.eat(); // 'Chomp chomp chomp!'
  console.log(pancake.isHungry); // undefined

  SÃ³lo este objeto que crearemos a continuaciÃ³n tendrÃ¡ acceso al prototipo actualizado.
  Y no tendrÃ¡ acceso al viejo prototipo.

  const muffin = new Hamster();
  muffin.eat(); // TypeError: muffin.eat is not a function
  console.log(muffin.isHungry); // false
  console.log(muffin.color); // 'brown'  

  Video
  â•â•â•â•â•
  const myArray = [1, 2, 3];
  myArray.join(''); // 123
  console.dir(myArray);

  Retorna:
  â–¼ Array(3)
    0: 1
    1: 2
    2: 3
    length: 3
    â–¼ __proto__: Array(0)
      â–¶ constructor: Æ’ Array()
      â–¶ etc.

  Enlista todos los mÃ©todos disponibles para llamar con nuestro array. Todos son prototÃ­picos.
  Estos mÃ©todos no son definidos en el array o en el objeto, sino que el array individual tiene acceso
  a mÃ©todos heredados del prototipo.

  Checking an Object s Properties
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Si un objeto no tiene una propiedad partircular en sÃ­ misma, puede acceder a alguna desde algÃºn lugar 
  de la cadena prototÃ­pica, asumiendo que exista. Con tantas opciones resulta tricky decir de donde 
  proviene una propiedad particular. 

  Los siguientes mÃ©todos pueden resultar Ãºtiles para este tipo de casos:

  hasOwnProperty()
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Nos permite encontrar el origen de una propiedad. Pasando el string de la propiedad que estamos buscando,
  el mÃ©todo retornarÃ¡ un boolean indicando si esa propiedad pertenece o no a ese objeto, es decir esa 
  propiedad no es heredada. 

  function Phone() {
    this.operatingSystem = 'Android';
  }
  Phone.prototype.screenSize = 6;

  const myPhone = new Phone();
  const own = myPhone.hasOwnProperty('operatingSystem');
  console.log(own);  // true

  const inherited = myPhone.hasOwnProperty('screenSize');
  console.log(inherited); // false

  Nos devuelve verdadero sobre la propiedad que fue creada dentro del constructor, pero falso para la propiedad
  que pertenece al prototipo.

  isPrototypeOf()
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Este mÃ©todo chequea si un objeto existe o no dentro de otra cadena de prototipos. Podemos confirmar si 
  un objeto particular sirve como prototipo para otro objeto.

  const rodent = {
    favoriteFood: 'cheese',
    hasTail: true
  };  

  function Mouse() {
    this.favoriteFood = 'cheese';
  }

  Mouse.prototype = rodent;

  const ralph = new Mouse();
  const result = rodent.isPrototypeOf(ralph);
  console.log(result);  // true

  Para utilizar este mÃ©todo necesitamos saber el prototipo.

  Object.getPrototypeOf()
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  En el caso de que no estemos seguros de quÃ© prototipo sea podemos utilizar este mÃ©todo. 

  const rodent = {
    favoriteFood: 'cheese',
    hasTail: true
  };  

  function Mouse() {
    this.favoriteFood = 'cheese';
  }

  Mouse.prototype = rodent;

  const ralph = new Mouse();
  const myPrototype = Object.getPrototypeOf(ralph);
  console.log(myPrototype); // { favoriteFood: 'cheese', hasTail: true }

  The constructor Property
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Cada vez que un objeto es creado una propiedad especial es asignada por debajo: constructor.
  Accediendo a la propiedad del constructor del objeto podemos retornar una referencia de la 
  funciÃ³n constructora que crea ese objeto en primer lugar. 

  function Longboard() {
    this.material = 'bamboo';
  }

  const board = new Longboard();

  console.log(board.constructor);
  // function Longboard() {
  //   this.material = 'bamboo';
  // }

  Recuerda que en el caso de que el objeto haya sido creado con notaciÃ³n literal el constructor 
  serÃ¡ Object()

  const rodent = {
    favoriteFood: 'cheese',
    hasTail: true
  };

  console.log(rodent.constructor);  // function Object() { [native code] }

  Question
  â•â•â•â•â•â•â•â•
  What is true about hasOwnProperty()? 
  - It returns a boolean indicating whether the object has the specified property as its own 
    property (i.e., the property isn t inherited)
  - hasOwnProperty() is invoked as a method onto an object

  What is true about isPrototypeOf() or getPrototypeOf()? Select all that apply:
  - isPrototypeOf() checks whether or not an object exists in another object s prototype chain
  - isPrototypeOf() takes a single argument: an object whose prototype chain is to be searched
  - getPrototypeOf() returns the prototype of the object passed into It

  What is true about constructor property? Select all that apply:
  - Accessing an object s constructor property returns a reference to the constructor function 
  that created that object (instance)
  - Every object has a constructor property
  - Objects created with literal notation are constructed with the Object() constructor function
  
  Question
  â•â•â•â•â•â•â•â•
  Let s say that we create the following object, capitals, using regular object literal notation:

  const capitals = {
    California: 'Sacramento',
    Washington: 'Olympia',
    Oregon: 'Salem',
    Texas: 'Austin'
  };

  What is returned when Object.getPrototypeOf(capitals) is executed?
  A reference to Object() s prototype

  This one may have been tricky! Keep in mind that since capitals was created with object literal 
  notation, its constructor is the built-in Object() constructor function itself! As such, it maintains 
  a reference to its constructor s prototype. That is,
  
  Object.getPrototypeOf(capitals) === Object.prototype; // true

  Summary
  â•â•â•â•â•â•â•
  Herencia en JS es cuando un objeto se basa en otro objeto. La herencia nos permite reusar cÃ³digo
  existente, teniendo objetos tomamos propiedades de otros objetos.

  Cuando llamamos a una funciÃ³n usando el operador new la funciÃ³n crea y devuelve un nuevo objeto.
  Este objeto es secretamente enlazado al prototipo de su constructor, que es otro objeto.
  Usando este enlace secreto nos permite acceder a las propiedades y mÃ©todos del prototipo como si
  fueran propios. Si JS no encuentra una propiedad particular en un objeto, seguirÃ¡ buscando en la
  cadena prototÃ­pica, eventualmente alcanzado Object() en el nivel top parent.

  TambiÃ©n vimos los mÃ©todos:
  - hasOwnProperty()
  - isPrototypeOf()
  - Object.getPrototypeOf()
  - .constructor

  Further Research
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - Object Playground: http://www.objectplayground.com/
  - hasOwnProperty() on MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty
  - isPrototypeOf() on MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isPrototypeOf
  - Object.getPrototypeOf() on MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf
  - .constructor on MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  3.6. Prototypal Inheritance: Subclases
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Subclasses
  â•â•â•â•â•â•â•â•â•â•
  Uno de los beneficios de implementar herencia es que nos permite reutilizar cÃ³digo existente.
  Estableciendo herencias, podemos subclass, eso es tener un hijo objeto con la mayorÃ­a o todas
  las propiedades padre mientras mantiene propiedades Ãºnicas por sÃ­ mismo.
  Digamos que tenemos un objeto padre Animal, que contiene propiedades como edad y peso. El mismo
  animal puede acceder tambiÃ©n a mÃ©todos como comer y dormir.
  Ahora, digamos tambiÃ©n, que quisiÃ©ramos crear un hijo objeto Cat. AsÃ­ como podemos hacer con otros
  animales, tambiÃ©n podemos describir la edad o peso del gato, y tambiÃ©n sabemos que puede tambiÃ©n
  comer y dormir. 
  Cuando creamos un objeto Cat, entonces podemos simplemente re escribir y re implementar esos 
  mÃ©todos y propiedades de Animal. O podemos ahorrar cierto tiempo y prevenir cÃ³digo repetido
  haciendo que Cat herede las existentes propiedades y mÃ©todos desde Animal.
  No sÃ³lo puede Car tomar las propiedades o mÃ©todos de Animal, sino tambiÃ©n dar a Cat sus propiedades
  y mÃ©todos Ãºnicos. Tal vez Cat tenga un propiedad lives con un valor de 9 o tenga un mÃ©todo especial
  meow() que Animal no tiene.
  
  Utilizando herencia prototÃ­pica, Cat sÃ³lo necesita implementar funcionalidades especÃ­ficas de Cat,
  y reutilizar las existentes funcionalidades ya en Animal.

  Inheritance Via Prototypes
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Recordemos la cadena prototÃ­pica de la secciÃ³n previa:

                          â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—  â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—  â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
                          â•‘   constructor   â•‘  â•‘   constructor   â•‘  â•‘   constructor   â•‘
  â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—  new  â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£  â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£  â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
  â•‘    bailey     â•‘   â†µ   â•‘       Cat()     â•‘  â•‘     Animal()    â•‘  â•‘     Object()    â•‘
  â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£       â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•  â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•  â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• 
  â•‘    lives      â•‘                â”‹                    â”‹                    â”‹           â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
  â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•       â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—  â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—  â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—  â•‘    undefined    â•‘    
          â•¹               â•‘    prototype    â•‘  â•‘    prototype    â•‘  â•‘    prototype    â•‘  â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          â•¹               â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£  â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£  â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£           â•¹
          â”—â•ºâ•ºâ•ºâ•ºâ•ºâ•ºâ•ºâ•ºâ•ºâ•ºâ•ºâ•ºâ•ºâ•º â•‘      meow()     â•‘â•ºâ•ºâ•‘     kingdom     â•‘â•ºâ•ºâ•‘ hasOwnProperty()â•‘â•ºâ•ºâ•ºâ•ºâ•ºâ•ºâ•ºâ•ºâ•ºâ•ºâ•ºâ”› 
                          â•‘                 â•‘  â•‘  calculateAge() â•‘  â•‘ isPrototypeOf() â•‘
                          â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•  â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•  â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• 

  Cuando llamamos cualquier propiedad en cualquier objeto, el motor JS primero busca la propiedad en el
  objeto mismo. Si la propiedad no es encontrada buscarÃ¡ en el prototipo del objeto. Si la propiedad aÃºn
  no es encontrada JS seguirÃ¡ buscando en la candena prototÃ­pica.

  Otra vez, herencia en JS es todo acerca de setear esta cadena.

  The Secret Link
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  La funciÃ³n constructora de un objeto es el primer lugar donde el motor de JS intenta acceder a una 
  propiedad que no es encontrada en el objeto mismo. 

  const bear = {
    claws: true,
    diet: 'carnivore'
  }; // Nuevo objeto con dos propiedades

  function PolarBear() { 
    // ...
  }; // Creamos una funciÃ³n constructora

  PolarBear.prototype = bear; // Se la asignamos al prototipo de bear

  const snowball = new PolarBear(); // Creamos una instancia para el nuevo objeto

  snowball.color = 'white'; 
  snowball.favoriteDrink = 'cola'; // Y le asignamos dos propiedades
  
  {
    color: 'white',
    favoriteDrink: 'cola'
  }; // El objeto hasta ahora se ve asÃ­

  console.log(snowball.claws); // true 
  console.log(snowball.diet); // 'carnivore' - TambiÃ©n a las propiedades de bear

  Ambas propiedades existen en el prototipo del objeto, y son alcanzadas por este enlace secreto
  que tienen con las propiedades de la funciÃ³n constructora del prototipo.

  QuÃ© es este enlace secreto que hace referencia hacia el objeto prototipo? Justo despuÃ©s de que los
  objetos son creados desde el constructor PolarBear(), tienen acceso inmediato a las propiedades en
  el prototipo PolarBear(). Pero cÃ³mo es posible?

  La propiedad __proto__ de snowball es una propiedad de todos los objetos, hechos por una funciÃ³n
  constructora, y apunta directamente a la constructora del prototipo del objeto. 

  console.log(snowball.__proto__); // { claws: true, diet: 'carnivore' }

  Como la propiedad __proto__ refiere al mismo objeto como el prototipo de PolarBear, bear al compararlos
  retorna true:

  console.log(snowball.__proto__ === bear); // true

  Es altamente DESACONSEJABLE reasignar el objeto __proto__ o utilizarlo en cualquier cÃ³digo que 
  escribas. 
  Primero, hay problemas de compatibilidad cross-browser.
  Como el motor JS busca y accede a propiedades a lo largo de la cadena prototÃ­pica, mutar la propiedad
  de un objeto puede llevar a problemas de performance.
  Tampoco debe utilzarse para manejar herencia. Si alguna vez sÃ³lo necesitas rever el prototipo de un
  objeto todavÃ­a puedes utilizar Object.getPrototypeOf().

  ğŸ’¡ What About Just Inheriting the Prototype? ğŸ’¡
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Digamos que queremos que Child herede desde Parent. Por quÃ© no deberÃ­amos setear 
  Child.prototype = Parent.prototype ?

  Primero, recordemos que los objetos son pasados por referencia. Esto quiere decir que Child.prototype
  y Parent.prototype refieren al mismo objeto, cualquier cambio realizado en Child se harÃ¡ tambiÃ©n en 
  Parent. No queremos que que los hijos sean capaces de modificar las propiedades de sus padres.

  Encima de todo esto, ninguna cadena prototÃ­pica serÃ¡ seteada. QuÃ© pasa si queremos que un objeto 
  herede de cualquier objeto que querramos y no sÃ³lo su prototipo?
  Necesitamos un manejo aÃºn mÃ¡s eficiente de las herencias sin mutar el prototipo para nada.

  Question
  â•â•â•â•â•â•â•â•
  function GuineaPig (name) {
    this.name = name;
    this.isCute = true;
  }

  const waffle = new GuineaPig('Waffle');

  What does waffle.__proto__ refer to?
  GuineaPig.prototype

  Question
  â•â•â•â•â•â•â•â•
  function Car (color, year) {
    this.color = color;
    this.year = year;
  }

  Car.prototype.drive = function () {
    console.log('Vroom vroom!');
  };

  const car = new Car('silver', 1988);

  What happens when car.drive() is executed? List the following events in the order that they occur:
  - Primero, el motor JS busca dentro del objeto car por una propiedad llamada drive
  - El motor JS no encuentra la propiedad drive dentro del objeto car
  - El motor JS entonces accede a la propiedad car.__proto__
  - Como la propiedad car.__proto__ apunta a Car.prototype, el motor JS busca drive en el prototipo
  - Como Car.prototype.drive es una funciÃ³n definida, es retornada
  - Finalmente, como drive es invocado como un mÃ©todo en car, el valor de this es seteado a car

  Object.create()
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Recordar: aunque podamos acceder al prototipo a travÃ©s de __proto__, no es una buena prÃ¡ctica.
  No deberÃ­amos utilizar la herencia desde el prototipo. Esto no permite que se setee la cadena 
  prototÃ­pica y cualquier cambio realizado en el objeto hijo se verÃ¡ reflejado en el objeto padre.

  Pero hay una forma de setear el prototipo de un objeto nosotros mismos: usando Object.create().
  Y lo mejor de todo, es que este approach nos permite manejar la herencia sin alterar el prototipo.

  Object.create() toma un simple objeto como argumento, y retorna un nuevo objeto que es la propiedad
  __proto__ seteada con el argumento pasado dentro de ella. Desde este punto, simplemente seteamos el
  objeto retornado para ser la funciÃ³n construnctora del prototipo del objeto hijo.

  const mammal = {
    vertebrate: true,
    earBones: 3
  }; // Seteamos el objeto mammal con dos propiedades

  const rabbit = Object.create(mammal); // El objeto retornado setearÃ¡ __proto__ del objeto pasado como arg

  console.log(rabbit); // {} - Esperamos que el objeto estÃ© vacÃ­o sin propiedades

  console.log(rabbit.__proto__ === mammal); // true - rabbit estÃ¡ enlazado a mammal.

  console.log(rabbit.vertebrate); // true
  console.log(rabbit.earBones); // 3

  Esto quiere decir que rabbit se extiende de mammal. Como resultado rabbit puede acceder a las propiedades
  de mammal.

  Object.create() nos da un mÃ©todo limpio para establecer herencia prototÃ­pica en JS. Podemos fÃ¡cilmente
  extender la cadena prototÃ­pica de esta manera y podemos tener objetos heredados desde cualquier objeto
  que querramos.

  function Animal (name) {
    this.name = name;
  }

  Animal.prototype.walk = function () {
    console.log(`${this.name} walks!`);
  };

  function Cat (name) {
    Animal.call(this, name); // Llamamos al superconstructor para la instancia cat u objetos cat, sino this.name serÃ¡ undefined
    this.lives = 9;
  }

  Cat.prototype = Object.create(Animal.prototype); // Hacemos que Cat herede de Animal

  Cat.prototype.constructor = Cat; // Cambiamos el constructor, sino todos los Cat apuntarÃ¡n a Animal

  Cat.prototype.meow = function () {
    console.log('Meow!'); // Creamos un mÃ©todo
  };

  const bambi = new Cat('Bambi'); // Creamos un objeto Cat

  bambi.meow(); // Meow! 
  bambi.walk(); // Bambi walks!
  bambi.name; // Bambi

  Question
  â•â•â•â•â•â•â•â•
  Consider the following:

  function Parent() {
    // ...
  }

  function Child() {
    // ...
  }

  Child.prototype = Object.create(Parent.prototype);
  const child = new Child();

  The following is then executed: child instanceof Parent;

  What is printed to the console? true

  Question
  â•â•â•â•â•â•â•â•
  What is true about Object.create()?
  - It returns a new object whose __proto__ property is set to the object passed into Object.create()
  - Using Object.create(), we can have objects inherit from just about any object we want (i.e., not 
    only the prototype)
  - Object.create() allows us to implement prototypal inheritance without mutating the prototype

  Summary
  â•â•â•â•â•â•â•
  Herencia en JS es sobre setear la cadena prototÃ­pica. Esto permite subclasear, crear hijos objeto
  que hereden la mayorÃ­a o todas las propiedades y mÃ©todos padre. Podemos entonces implementar cualquier
  propiedad o herencia particular al hijo de manera separada, mientras mantenemos data y funcionalidades
  de sus padres.

  Un objeto o instancia, estÃ¡ secretamente linkeado al objeto prototipo de su funciÃ³n constructora a travÃ©s
  de la propiedad __proto__. No debemos utilizar __proto__ en nuestro cÃ³digo, esto  llevarÃ­a a efectos no
  deseados.

  Para manejar la herencia de manera efectiva en JS y para evitar mutaciones del prototipo existe
  Object.create() que nos permite justamente hacer eso, tomar un objeto padre y retornar un nuevo objeto
  con su propiedad __proto__ seteada por el objeto padre.

  Further Research
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - Inheritance and the prototype chain on MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain
  - Object.create() on MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create
  
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  3.7. Lesson Summary
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  3.8. Course Outro
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•