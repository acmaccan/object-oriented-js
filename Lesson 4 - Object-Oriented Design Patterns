â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘   Object-Oriented JavaScript  â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  4. Object-Oriented Design Patterns
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  4.1. Introduction
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - Mixins
  - Module Pattern
  - Revealing Module Pattern

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  4.2. Mixins / Extending Object Functionality with Mixins
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  An Object is Prototype-linked to a Single Object
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Recordemos que la propiedad .prototype de un objeto apunta sÃ³lo a UN objeto. Esto es porque 
  JS soporta herencia simple. Si hay un objeto A y un objeto B, objeto C puede solor recibir de
  A o B. El objeto cat estÃ¡ linkeado al prototipo de un sÃ³lo objeto: animal.

                    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—     â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
                    â•‘         animal          â•‘     â•‘     cat      â•‘
                    â•‘  {                      â•‘     â•‘  {           â•‘
                    â•‘    kingdom: 'Animalia'  â•‘â•ºâ•ºâ•ºâ•ºâ•ºâ•‘    lives: 9  â•‘
                    â•‘  }                      â•‘     â•‘  }           â•‘
                    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•     â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  Question
  â•â•â•â•â•â•â•â•
  What is true about the following?

  const aircraft = {
    flies: true
  };

  const helicopter = Object.create(aircraft);

  console.log(helicopter.flies); // true

  - The helicopter object has no properties of its own
  - helicopter is prototype-linked to aircraft

  Mixins
  â•â•â•â•â•â•

  Si un objeto JS sÃ³lo puede ser prototÃ­picamente enlazado a un objeto, cÃ³mo podrÃ­amos extender
  propiedades y mÃ©todos de mÃºltiples fuentes? Podemos hacelo con mixins. 
  Mixin es una tÃ©cnica que permite tomar las propiedades y mÃ©todos de un objeto, y copiarlas en
  otro objeto. 
  De esta forma generamos objetos con nuevas funcionalidades sin involucrar herencias y que no
  pertenecen a la cadena prototÃ­pica del objeto.

  Object.assign()
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  La manera mÃ¡s sencilla de implementar mixin patterns es usando Object.assign(), un mÃ©todo que
  copia las propiedades de uno o mÃ¡s objetos source dentro de un objeto target. Luego retorna 
  ese objeto target actualizado.

  let target = {};
  let source = { number: 7 };
  Object.assign(target, source);

  console.log(target); // { number: 7 }

  El primer argumento pasado en target, es el destino que va a recibir las propiedades copiadas
  del objeto source. Notemos que Object.assign() no crea y retorna un nuevo objeto. Directamente
  modifica y luego retorna el mismo objeto target que fue pasado dentro. Entonces, los valores
  existentes serÃ¡n sobreescrito, mientras que las propiedades que no existan en el objeto source
  permanecerÃ¡n intactas.

  let target = { letter: 'a', number: 11 };
  let source = { number: 7 };
  Object.assign(target, source);

  console.log(target); // { letter: 'a', number: 7 }

  Multiple Source Objects
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Object.assign() puede tomar diferentes objetos source. 

  const duck = {
    hasBill: true,
    feet: 'orange'
  };
  const beaver = {
    hasTail: true
  };
  const otter = {
    hasFur: true,
    feet: 'webbed'
  };

  const platypus = Object.assign({}, duck, beaver, otter);
  console.log(platypus); // { hasBill: true, hasTail: true, hasFur: true, feet: 'webbed' }

  Luego de mergear un objeto vacÃ­o con las propiedades de duck, beaver y otter el objeto target
  es retornado con todas, las cuatro propiedades. Es importante notar que platypus no estÃ¡ linkeado
  con el prototipo de los otros tres objetos, platypus no existe en la cadena prototÃ­pica de los
  tres objetos y viceversa.

  platypus.constructor; // Object()
  platypus.isPrototypeOf(duck); // false
  duck.isPrototypeOf(platypus); // false
  platypus.isPrototypeOf(beaver); // false
  beaver.isPrototypeOf(duck); // false
  platypus.isPrototypeOf(otter); // false
  otter.isPrototypeOf(platypus); // false

  âš ï¸ Object.assign() Compatibility âš ï¸
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Object.assign() fue introducido a la especificaciÃ³n ES2015 (ES6), por lo que puede presentar
  problemas de compatibilidad: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Browser_compatibility

  Question
  â•â•â•â•â•â•â•â•
  Let s modify the above code a bit. 

  const duck = {
    hasBill: true
  };
  const beaver = {
    hasTail: true
  };
  const otter = {
    hasFur: true,
    feet: 'webbed'
  };

  const platypus = Object.assign(duck, beaver, otter);

  What is true after the following?
  - platypus is an object with four properties
  - duck becomes an object with four properties
  - platypus === duck

  Question
  â•â•â•â•â•â•â•â•
  What is true about multiple inheritance or mixins?
  - A mixin supplies properties and/or methods that can be shared
  - We can leverage Object.assign() to "mix in" properties and methods from a number of objects
    into a composite object

  Summary
  â•â•â•â•â•â•â•
  El mixin es una tÃ©cnica que copia data y funcionalidades desde un/os objeto/s source a un objeto
  target. Podemos implementarlo a travÃ©s del mÃ©todo Objeto.assign() (ES6) para retornar un objeto 
  target con propiedades de uno o mÃ¡s objetos mezclados dentro del objeto target.
  
  Further Research
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - Object.assign() on MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  4.3. Functional mixins
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  Remember Constructor Functions?
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Previamente utilizamos una funciÃ³n constructora para crear nuevo objetos:

  function City(name, population) {
    this.name = name;
    this.population = population;

    this.identify = function () {
      console.log(`${this.name} s population is ${this.population}.`);
    };
  };

  Para instanciarlo, invocamos una funciÃ³n con el operador new:

  const sanFrancisco = new City('San Francisco', 870000);
  console.log(sanFrancisco);

  {
    name: 'San Francisco',
    population: 870000,
    identify: function () {
      console.log(`${this.name} s population is ${this.population}.`);
    };
  }

  Podemos utilizar el mismo constructor para crear mÃºltiples objetos:

  const mountainView = new City('Mountain View', 78000);
  console.log(mountainView);
  {
    name: 'Mountain View',
    population: 78000,
    identify: function () {
      console.log(`${this.name} s population is ${this.population}.`);
    };
  }

  Notemos como utilizamos el operador new para la creaciÃ³n de cada uno de los objetos, cada vez.
  Las factory functions producen instancias de objeto sin el uso del operador new.

  Factory Functions
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Son funciones que retornan un objeto, pero en sÃ­ mismas no son una clase o un constructor. invocamos
  una factory function como una funciÃ³n normal sin utilizar el operador new. Con ella podemos crear
  fÃ¡cilmente instancias de objetos sin la complejidad de clases y constructores.

  function Basketball(color) {
    return {
      color: color,
      numDots: 35000
    };
  };

  Lo que es importante para notar aquÃ­ es que Basketball() retorna un objeto directamente. Es diferente
  de una constructor function que retorna su objeto automÃ¡ticamente.

  const orangeBasketball = Basketball('orange');
  console.log(orangeBasketball); // { color: 'orange', numDots: 35000 }

  Una factory function tiene su nombre, tal como una fÃ¡brica de sillas puede producir silla despuÃ©s de
  silla, una factory function puede ser usada una y otra vez para crear n objetos.

  const myBB = Basketball('blue and green');
  const yourBB = Basketball('purple');
  const bouncy = Basketball('neon pink');

  Invocando la factory function nos permite componer un simple objeto, sin el uso del operador new.
  Sumaricemos las diferencias entre factory function y constructor function.

  â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
  â•‘                                    â•‘ Factory Function           â•‘ Constructor Function       â•‘
  â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
  â•‘ Creates a new object?              â•‘ Yes                        â•‘ Yes                        â•‘     
  â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
  â•‘ Can be called multiple times       â•‘ Yes                        â•‘ Yes                        â•‘ 
  â•‘ to create multiple objects?        â•‘                            â•‘                            â•‘       
  â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
  â•‘ Can receive arguments?             â•‘ Yes                        â•‘ Yes                        â•‘     
  â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
  â•‘ Implicates prototypal inheritance? â•‘ No                         â•‘ Yes                        â•‘  
  â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
  â•‘ Invoked as...                      â•‘ A normal function          â•‘ With the new operator      â•‘
  â•‘                                    â•‘ factoryFunc()              â•‘ new constructorFunc()      â•‘
  â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• 

  Video
  â•â•â•â•â•
  Esta es una factory function que retorna un closure. Como la instancia de una clase, el closure
  tiene sus propias functiones y variables. 
  Tanto turnOn como isOn hacen referencia a la variable on declarada dentro de Radio. Lo que este
  objeto estÃ¡ haciendo es cerrar sobre una variable definida sobre la funciÃ³n padre. De esta forma,
  preserva su estado.

  function Radio(mode) {
    let on = false;

    return {
      mode: mode,
      turnOn: function () {
        on = true;
      },
      isOn: function () {
        return on;
      }
    };
  }

  let fmRadio = Radio('fm'); // Inovcamos la funciÃ³n y le asignamos fm a mode
  fmRadio.on; //undefined - No podemos acceder

  fmRadio; // Si miramos la estructura, on en sÃ­ mismo no es una propiedad del objeto fmRadio
    â–¶ { mode: "fm", turnOn: Æ’, isOn: Æ’ }

  fmRadio.isOn(); // false - Este mÃ©todo isOn hace referencia a on, podemos acceder a Ã©l a travÃ©s de isOn
  fmRadio.turnOn(); // Llamamos a este mÃ©todo
  fmRadio.isOn(); // true - ReasignÃ³ el valor de on

  Entonces, podemos aprovechar factory functions junto con closures para preservar estados.

  Functional Mixins
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Entonces, utilizamos mixins para agregar features a un objeto compuesto. TambiÃ©n aprovechamos
  factory functions para crear objetos sin el operador new o sin utilizar le herencia prototÃ­pica.
  Combinando todo esto podemos dar un paso mÃ¡s allÃ¡ con functional mixins.

  Un functional mixin es una factory function componible que recibe una mixin como argumento,
  copia propiedades y mÃ©todos desde esa mixin y retorna un nuevo objeto. 

  function CoffeeMaker(object) {
    let needsRefill = false;

    return Object.assign({}, object, {
      pourAll: function () {
        needsRefill = true;
      },
      isEmpty: function () {
        return needsRefill;
      }
    });
  }

  Notemos que a diferencia de una factory function standard, que toma valores individuales de una
  propiedad, la functional mixin en realidad toma un objeto en sÃ­ mismo. Cual sea el objeto pasado 
  en la funciÃ³n es mergeado con otros objetos pasados en Object.assign()

  const mixedCoffeeMaker = CoffeeMaker({ style: 'percolator' });

  El objeto mixedCoffeeMaker retornado:
  {
    style: 'percolator',
    pourAll: function () {
      needsRefill = true;
    },
    isEmpty: function () {
      return needsRefill;
    }
  }

  Functional mixins son componibles. Podemos utilizar piezar individuales de cÃ³digo para agregar
  propiedades especÃ­ficas como una lÃ­nea de ensamble. 

  function IceCreamFactory(obj) {  â†’ Toma un sÃ³lo objeto, tiene una variable local y retorna el valor de Object.assign
    let isCold = true;

        Objeto target vacÃ­o    Objeto source, el argumento de IceCreamFactory
                          â†‘    â†‘
    return Object.assign({}, obj, {   â†’ dos mÃ©todos: melt e isCold
      melt: function () {
        isCold = false                â†’ Cambia el valor de isCold
      },
      isCold: function () {
        return isCold                 â†’ Trae el valor de isCold
      }
    });
  }

  let iceCream = IceCreamFactory({}); // Guardamos la functional mixin en una variable

  iceCream; // Si vemos la estructura
    â–¶ { melt: Æ’, isCold: Æ’ }

  function ConeFactory(obj) {  â†’ Creamos otra, repitiendo la estructura anterior
    let isDry = true;

    return Object.assign({}, obj, {
      soggy: function () {
        isDry = false;
      },
      isDry: function () {
        return isDry;
      }
    });
  }
                                                  Objeto vacÃ­o
                                                  â†‘
  let iceCreamCone = IceCreamFactory(ConeFactory({})); // Retornamos el valor de coneFactory como argumento de IceCreamFactory

  iceCreamCone; // Si vemos la estructura
    â–¶ { soggy: Æ’, isDry: Æ’, melt: Æ’, isCold: Æ’ }

  console.log(iceCreamCone);

  Question
  â•â•â•â•â•â•â•â•
  What is true about factory functions or mixins?
  - Just like a constructor function, a factory function can be called multiple times to create an object

  Summary
  â•â•â•â•â•â•â•â•
  Una factory function crea objetos. Es invocada como una funciÃ³n normal sin el operador new.
  Con functional mixims podemos ir un poco mÃ¡s allÃ¡, aceptando un mixin como argumento, copia propiedades
  y mÃ©todos del mixin y retorna un nuevo objeto.
  
  Further Research
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - JavaScript Factory Functions vs Constructor Functions vs Classes by Eric Elliott: https://medium.com/javascript-scene/javascript-factory-functions-vs-constructor-functions-vs-classes-2f22ceddf33e
  - Factory Function Pattern In-Depth by Ronald Chen: https://medium.com/@pyrolistical/factory-functions-pattern-in-depth-356d14801c91

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  4.4. Module Pattern
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  Private Properties: Literal
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Por defecto, la mayorÃ­a de las cosas en JS son accesibles. Podemos utilizar closure para
  hacer ciertas partes del cÃ³digo privadas. Pero quÃ© pasa si queremos prevenir el acceso de
  manera directa? CÃ³mo podemos hacer que una propiedad o mÃ©todo sea privada e inaccesible desde
  fuera? 

  let developer = {
    name: 'Veronika',
    getName: function () {
      return this.name;
    }
  };

  Podemos acceder a 'Veronika' a travÃ©s de getName o de name:
  developer.getName(); // 'Veronika'
  developer.name; // 'Veronika'

  QuÃ© pasa si reasignamos el valor de nombre?
  developer.name = 'Not Veronika';
  developer.getName(); // 'Not Veronika'
  developer.name; // 'Not Veronika'

  ğŸ’¡Privacy with Underscores? ğŸ’¡
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Los guiones bajos que podemos llegar a ver en cÃ³digo son sÃ³lo convenciÃ³n entre desarrolladores
  para indicar una variable privada, pero no tiene funcionalidad.

  Private Properties: Function
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  QuÃ© pasa si creamos una funciÃ³n bÃ¡sica que sÃ³lo retorne un objeto? Da esto el nivel adecuado de
  protecciÃ³n?

  function instantiateDeveloper() {
    return {
      name: 'Veronika',
      getName: function () {
        return this.name;
      }
    };
  }; FunciÃ³n bÃ¡sica que retorna un objeto con dos propiedades: name y getName.

  let developer = instantiateDeveloper(); // Invoquemos la funciÃ³n para obtener el objeto

  El nombre todavÃ­a es accesible:
  developer.getName; // 'Veronika'
  developer.name; // 'Veronika'

  Lo que todavÃ­a hace posible mutar el objeto:
  developer.name = 'Not Veronika';
  developer.name; // 'Not Veronika'

  La funciones no puede proteger a los objetos de la mutabilidad.

  No Private Properties
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Como JS no tiene un concepto de propiedades privadas, no hay sintaxis especial o palabras clave
  que podamos utilizar para proteger ciertas propiedades de ser accedidas.

  Sin embargo, recordemos que aÃºn podemos hacer uso de scopes y closures para crear un estado 
  privado.
  function myCounter() {
    let count = 0;

    return function () {
      count += 1;
      return count; â†’ Se cierra sobre la variables count
    }; 
  }

  let counter = myCounter();
  counter(); // 1
  counter(); // 2

  No hay mÃ©todo fuera del closure que nos permita acceder a count:
  counter.count; // undefined
  count; // undefined

  Entonces, closure nos provee una forma de crear data privada. Podemos sacar provecho de esta
  tÃ©cnicas, scope y closure, para crear propiedades y mÃ©todos privados en un objeto?

  Video
  â•â•â•â•â•
  En vez de utilizar un objeto literal o una simple funciÃ³n para crear privacidad podemos utilizar
  una unidad de organizaciÃ³n un poco mÃ¡s grande llamada mÃ³dulo, para alcanzar verdadera privacidad.
  Ã‰sta se ha vuelto una tÃ©cnica comÃºn y es conocida como module pattern. Este patrÃ³n utilza scope y
  closures para proteger las variables del acceso externo.
  
  Question
  â•â•â•â•â•â•â•â•
  Before we jump into how the Module Pattern leverages scope and closures, let s make sure we re on 
  the same page regarding scope. Consider the following:

  const myName = 'Richard';

  function introduceMyself() {
    const you = 'student';

    function introduce(message) {
      // Which variables can be used here?
    }

    return introduce('Hello');
  }

  Which variables does the nested introduce() function have access to?
  - myName - global
  - you - local
  - message - argument

  Question
  â•â•â•â•â•â•â•â•
  Consider the following:

  let sodiumChloride = (function(){
    let chemicalFormula = 'NaCl';
    let molarMass = 58.44;

    return {
      getProperties: function(){
        console.log(`Formula: ${chemicalFormula}`);
        console.log(`Molar Mass: ${molarMass} g/mol`);
      }
    };
  })();

  When sodiumChloride.getProperties() is executed, what is logged to the console?
  - Two strings: 'Formula: NaCl' and 'Molar Mass: 58.44 g/mol'

  Recall that IIFEs are great for creating private state. That is, by wrapping chemicalformula 
  and molarmass in an immediately-invoked function expression, those variables are inaccessible 
  from the outside world.

  Module Pattern utiliza los funcionalidades de scope, closures e IIFEs para crear estados privados.

                FunciÃ³n inmediatamente invocada
                â†‘
  let person = (function () {
    let name = 'Veronika'; â†’ Variable local

    return  {
      getName: function () {
        return name; â†’ getter
      },
      setName: function (myName){
        name = myName; â†’ setter
      }
    };
  })(); â†’ ParÃ©ntesis de invocaciÃ³n

  person.name; // undefined - Porque no estÃ¡ definido como propiedad en el objeto person
  person.getName; // 'Veronika' - Pero podemos acceder a travÃ©s de este mÃ©todo
  person.setName('Not Veronika'); // Y podemos aÃºn setear el valor de name a travÃ©s de este mÃ©todo
  person.getName; // 'Not Veronika' - Comprobamos que name se ha modificado

  Y de esta forma podemos mantener un acceso privado a nuestros objetos, si no es a travÃ©s de funciones
  definidas por nosotros mismos. Recordemos que JS no tiene funcionalidad de privacidad por default.

  The Module Pattern: Recap
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  let diana = (function () {
    let secretIdentity = 'Diana Prince';

    return {
      introduce: function () {
        console.log(`Hi! I am ${secretIdentity}`);
      }
    };
  })();

  Recordemos que el uso de IIFEs no sÃ³lo previene la poluciÃ³n global a travÃ©s del scope sino que previene
  de accesos indeseados a ciertas variables.
  console.log(diana.secretIdentity); // undefined

  Y porque el objeto retornado de introduce() retiene el acceso al scope de las funciones padres, podemos
  dar una interfaz pÃºblica para interactuar con secretIdentity();
  diana.introduce(); // 'Hi! I am Diana Prince'
  
  Other Benefits of the Module Pattern
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Hay otros beneficios mÃ¡s allÃ¡ de la privacidad, al incorporar el module pattern. 
  - OrganizaciÃ³n: los mÃ³dulos son grandes unidades de organizaciÃ³n para funciones y objetos. Esto ayuda a 
  particionar el cÃ³digo y proveer una estructura mientras la applicaciÃ³n escala.
  - Utilizamos module pattern cuando queremos sÃ³lo una veriÃ³n de un objeto. Si estamos buscando instanciar
  objetos que sigan una cierta blueprint, siempre podemos escribir e invocar una funciÃ³n constructora.

  Question
  â•â•â•â•â•â•â•â•
  What is true about the Module Pattern?
  - The Module Pattern uses closures to create private properties
  - The Module Pattern requires the use of IIFEs
  - Unlike calling a constructor function, implementing the Module Pattern returns just one version of an object

  Summary
  â•â•â•â•â•â•â•
  Como JS no tiene variables, propiedades o mÃ©todos privados, podemos utilizar el module pattern
  para forzar la privacidad. En su core utiliza scopes, closures e IIFEs no sÃ³lo para esconder 
  data desde el acceso externo sino para proveer de una interfaz pÃºblica con esa data.

  Further Research
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - Addy Osmani s The Module Pattern (JavaScript Design Patterns): https://addyosmani.com/resources/essentialjsdesignpatterns/book/#modulepatternjavascript
  - Todd Motto s Mastering the Module Pattern: https://toddmotto.com/mastering-the-module-pattern/#private-methods 

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  4.5. The Revealing Module Pattern
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  Video
  â•â•â•â•â•
  Este patrÃ³n es muy similar al anterior, la filosofÃ­a debajo es la misma. La utilizamos para 
  mantener la encapsulaciÃ³n. Pero en este patrÃ³n toda la data es privada y sÃ³lo la que el
  desarrollador considere es revelada pÃºblicamente.

                  IIFE
                  â†‘
  let myModule = (function (){
    function privateMethod (message) { 
      console.log(message); â†’ Creamos un mÃ©todo privado
    }

    function publicMethod (message) {
      privateMethod(message); â†’ Creamos un mÃ©todo pÃºblico
    }

    return {
      publicMethod: publicMethod  
    };  â†’ Retornamos un objeto con una funciÃ³n pÃºblica
  })(); â†’ ParÃ©ntesis para inmediatamente invocar a la funciÃ³n

  myModule; // Si vemos la estructura
    â–¶ { publicMethod Æ’ }

  myModule.publicMethod('hello there');
  // hello there

  The Revealing Module Pattern
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  La filosofÃ­a subyacente del Revealing Module Pattern es esa, mientras todavÃ­a mantenemos
  la encapsulaciÃ³n (como en el Module Pattern), tambiÃ©n podemos revelar ciertas propiedades
  y mÃ©todos. Los ingredientes clave del Revealing Module Pattern:
  - Una IIFE (wrapper)
  - El contenido del mÃ³dulo (variables, mÃ©todos, objetos, etc)
  - El retorno de un objeto literal

  Another Example
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  let person = (function () {
    let privateAge = 0;          â†’ Data privada
    let privateName = 'Andrew';  â†’ Data privada

    function privateAgeOneYear() { 
      privateAge += 1;           â†’ Data privada
      console.log(`One year has passed! Current age is ${privateAge}`);
    }

    function displayName() {
      console.log(`Name: ${privateName}`);
    }

    function ageOneYear() {
      privateAgeOneYear();
    }

    return {   
      name: displayName,
      age: ageOneYear
    };  â†’ El objeto retornado nos provee de una interfaz pÃºblica para acceder a la informaciÃ³n
  })();

  person se ve:
  {
    name: displayName,
    age: ageOneYear
  };

  name revela la funciÃ³n privada displayName()
  console.log(person.name()); // 'My name is Andrew'

  QuÃ© pasa si intentamos acceder a ese mÃ©todo y mutarlo?
  person.privateName = 'Richard'; â†’ EstÃ¡ intentando accede a privateName porque sÃ³lo existe en la IIFE misma
  console.log(person.name()); // 'My name is Andrew'
  
  Notemos que tampoco serÃ¡ efectivo accediendo a displayName()
  console.log(person.displayName()); // undefined

  De la misma manera el Revealing Module Pattern tambiÃ©n nos brinda a cceso a la variable privateAge
  vÃ­a el mÃ©todo del objeto retornado:
  console.log(person.age()); // 'One year has passed! Current age is 1'
  console.log(person.age()); // ''One year has passed! Current age is 2'

  Question
  â•â•â•â•â•â•â•â•
  Which concepts make up the Revealing Module Pattern?
  - IIFE
  - Local variables/functions
  - Returned object literal with keys that point to data intended to be revealed

  Benefits of the Revealing Module Pattern
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Cuando escribimos mÃ³dulos, contamos con algunas ventajas usando este patrÃ³n.

  - Mayor claridad: al final del mÃ³dulo, en el return statement, donde encontramos las variables y
  mÃ©todos que pueden ser accedidos pÃºblicamente. Los mÃ³dulos pueden crecer y facilita la lectura para
  otros desarrolladores que lean tu cÃ³digo.
  
  - Sintaxis consistente. En contraste el Module Pattern normal, puede contenter variables y funciones 
  repartidas por todo el cuerpo de la funciÃ³n.

  Nada puede salir mal con ninguno de los dos approaches para crear data privada, pero es importante
  dedicar tiempo a pensar cuÃ¡l tiene mayor sentido para nuestro proyecto.

  Summary
  â•â•â•â•â•â•â•
  El Revealing Module Pattern es una ligera variaciÃ³n del Module Pattern. IIFEs, variables y funciones
  locales, y el retorno de un objeto literal con data revelada hace a la estructura y sintaxis de este
  patrÃ³n. Mientras se mantiene la encapsulaciÃ³n de la data, ciertas variables y funciones son retornadas
  en un objeto literal.

  Further Research
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - Addy Osmani s The Revealing Module Pattern (JavaScript Design Patterns): https://addyosmani.com/resources/essentialjsdesignpatterns/book/#revealingmodulepatternjavascript
  - Christian Heilmann s Again with the Module Pattern â€“ reveal something to the world: https://christianheilmann.com/2007/08/22/again-with-the-module-pattern-reveal-something-to-the-world/

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  4.6. Lesson Summary
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  4.7. Course Outro
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - Objects: create, access and modify objects
  - Functions at runtime
  - Scopes, closures, IIFEs
  - Combinamos all to create our oun classes
  - Constructor functions
  - this keyword
  - Prototype inheritance to create and extend objects
  - Object-oriented Design Patterns: create, extend and add privacy to object.
  

